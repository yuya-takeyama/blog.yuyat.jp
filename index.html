<!DOCTYPE html>
<html lang="ja-jp">
  <head>
	<meta name="generator" content="Hugo 0.16" />
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://blog.yuyat.jp/stylesheets/shiori.css">
    <link href='//fonts.googleapis.com/css?family=Montserrat:700,400' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic' rel='stylesheet' type='text/css'>
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="shortcut icon" href="https://blog.yuyat.jp/favicon.ico">
    <link rel="canonical" href="https://blog.yuyat.jp/">
    <title>Born Too Late | Born Too Late</title>
    

    <meta property="fb:admins" content="100000987494966" />
<meta property="fb:app_id" content="285547814816502" />
<meta property="og:title" content="Born Too Late" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://blog.yuyat.jp/" />

  
	  <meta property="og:image" content="https://blog.yuyat.jp/images/avatar.jpg" />
  


  <meta property="og:updated_time" content="2016-11-27T02:43:58&#43;09:00"/>




    <meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@yuya_takeyama">
<meta name="twitter:creator" content="@yuya_takeyama">

    

  </head>
  <body>
    <div class="navbar navbar-inverse navbar-static-top">
      <div class="container">
        <div class="navbar-header">
          <div class="navbar-toggle-wrapper visible-xs">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".js-navbar-collapse">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
          </div>
          <a href="https://blog.yuyat.jp" class="navbar-brand">Born Too Late</a>
        </div>
        <div class="collapse navbar-collapse js-navbar-collapse">
          <ul class="navbar-nav nav">
            <li><a href="https://blog.yuyat.jp/post/">Archive</a></li>

          </ul>
          <ul class="navbar-nav nav navbar-right">
            

          </ul>
        </div>
      </div>
    </div>
    <div class="container">

<div class="row">
  <div class="col-sm-8">
    
      
        <div class="post-header-home">
  <h1 class="post-title-home">
    <a href="https://blog.yuyat.jp/post/ghissue-a-command-to-create-github-issues/">GitHub の Issue を作るコマンド ghissue を作った</a>
  </h1>
  <p class="text-muted">Nov 27, 2016</p>

</div>
<div class="post-excerpt-home">
  作りました。 yuya-takeyama/ghissue なぜ作ったか いろいろな自動化スクリプトを書く中で、Octokit とかで毎回実装するのは面倒だったので、標準入力だけ食わせればいい感じにやってくれるものが欲しいな、と思って作りました。 タイトル・本文だけを標準出力に書き出すスクリプトだけ書けば、それをパイプで繋げるだけで ghissue が Issue を立ててくれます。 タイトル・本文だけうまく組み立てることに集中すればよくなり、テストも楽になるでしょう。 類似ツールとしては ghi というツールがありますが、これは標準入力からタイトル・本文を指定することができないので、他のコマンドと組み合わせて使うのはやや面倒です。 また、ghi が Ruby なのに対して、ghissue は Go で実装されていてコンパイル済みのバイナリも GitHub からダウンロードできます。 使い方 アクセストークンの指定 GitHub のアクセストークンを GITHUB_ACCESS_TOKEN という環境変数で指定します。 Issue を作る $ some_command | ghissue yuya-takeyama/test --labels Bug,Major --assignees yuya-takeyama some_command は Issue のタイトル・本文を生成するためのコマンドです。 1 行目がタイトルになり、残りは本文になります。 --labels (-l) ではラベルを指定します。カンマ区切りで複数指定可能です。 --assignees (-a) では assignee を指定します。これもカンマ区切りで複数指定可能です。 その他 Issue を編集する機能・コメントを記入するための機能もあっていいだろうと思うものの、今のところ個人的には必要としてないので、まぁそのうち。 よければご利用ください。
  
</div>

      
    
      
        <div class="post-header-home">
  <h1 class="post-title-home">
    <a href="https://blog.yuyat.jp/post/run-docker-container-in-digitalocean/">Docker コンテナを DigitalOcean 上でサクッと動かす</a>
  </h1>
  <p class="text-muted">Oct 11, 2016</p>

</div>
<div class="post-excerpt-home">
  やりたいこと 任意のアプリの Docker コンテナをサクッと立ち上げたい かつグローバル IP アドレスを割り当てて外から接続したい より具体的には、今回は mitmproxy をインターネット上で動かして iPhone 等のスマートフォン端末からつなぎたかった、という感じです。 手順 DigitalOcean のアカウントを作成する ここは割愛。 DigitalOcean のアクセストークンを作成 API -&gt; Tokens -&gt; Generate New Token から適当に名前をつけて作ります。 docker-machine で Docker 環境を作る docker-machine のインストール手順については割愛。 Mac だと Homebrew でもインストールできるので適当にやっておく。 $ docker-machine create --driver digitalocean --digitalocean-access-token=ACCESS_TOKEN --digitalocean-region=sgp1 mitmproxy --digitalocean-access-token には前の手順で作ったアクセストークンを指定。 --digitalocean-region にはリージョンの slug を指定します。 省略すると New York にできてレイテンシが辛いので、日本からだとシンガポールでも指定しておくのがいいでしょう。 リージョンの slug 一覧はこんな感じに最新版を取得できます。 $ curl -H &quot;Content-Type: application/json&quot; -H &quot;Authorization: Bearer ACCESS_TOKEN&quot; &quot;https://api.digitalocean.com/v2/regions&quot; -s | jq
  
  <p class="text-right"><a href="https://blog.yuyat.jp/post/run-docker-container-in-digitalocean/">Continue Reading &rarr;</a></p>
  
</div>

      
    
      
        <div class="post-header-home">
  <h1 class="post-title-home">
    <a href="https://blog.yuyat.jp/post/visualize-docker-metrics-with-redash/">Docker のメトリクスを Re:dash でビジュアライズ</a>
  </h1>
  <p class="text-muted">Oct 2, 2016</p>

</div>
<div class="post-excerpt-home">
  しばらく前から Dokku という Docker ベースの Heroku ライクな PaaS 基盤を趣味で運用していて、その中で旧ブログの WordPress や 自分用のツールなんかを動かしたりしている。 サーバのメトリクス収集には Mackerel を利用しているが、Docker コンテナ単位での計測は行っていなかった。 Mackerel はホスト数に応じた課金を行っていて、5 ホストまでは無料だが、コンテナまで追加してしまうとすぐにその枠を溢れてしまう。 というわけで簡単な仕組みを自分で用意いてみた。 できたもの どちらもメモリ使用量 (MB) をコンテナ名ごとにグラフ化したもので、どちらもデータは同じものを使っている。 後者はグラフを積み上げることでコンテナ全体で使用しているメモリの使用量もわかるようになっている。 今のところ Docker のリソースに関して困っているのはメモリだけなので、とりあえずはこれだけ。 なお、Dokku ではコンテナ名が アプリ名.プロセス名.プロセス番号 という感じになる (例えば blog.web.1 といった具合) になるので、アプリを再起動してコンテナ ID が変わっても連続的にモニタリングできる。 グラフ中異常値っぽいのが出ているところはまさにアプリを再起動したりしているところ。 概要 以下のような流れでこのグラフを作り出している。 fluent-plugin-docker-metrics で Docker のメトリクスを td-agent に収集 fluent-plugin-bigquery でメトリクスを BigQuery に送信 Re:dash で BigQuery 上のデータをグラフ化 手順 fluent-plugin-docker-metrics のセットアップ td-agent.conf の設定はこんな感じ。 &lt;source&gt; @type docker_metrics stats_interval 1m tag_prefix docker.metrics &lt;/source&gt; tag_prefix はデフォルトだと
  
  <p class="text-right"><a href="https://blog.yuyat.jp/post/visualize-docker-metrics-with-redash/">Continue Reading &rarr;</a></p>
  
</div>

      
    
      
        <div class="post-header-home">
  <h1 class="post-title-home">
    <a href="https://blog.yuyat.jp/post/rmp-quipper-food-and-drink-meetup/">【RMP×Quipper】Food&amp;Drink meetup #3 で発表した</a>
  </h1>
  <p class="text-muted">Oct 1, 2016</p>

</div>
<div class="post-excerpt-home">
  Quipper とその親会社であるところのリクルートマーケティングパートナーズ (RMP) とでの合同イベント (平たくいうと採用イベント) があって、LT の発表枠が空いていたので発表してきた。 スライドは Qiita のスライド機能を初めて使ってみた。 スクリーンに写すと文字が結構小さかったので、事前のチェックが大事だと思った。 curl でサッとベンチマークをとる (スライド版) 内容的には以前同じく Qiita に書いた記事 を加筆・再編集した程度のものなので、準備にはあまり時間がかかっていない。 Google Chrome の Developer Tools からリクエストを curl コマンドとしてコピーする機能について知らない人が意外と多かったので、その点が一番バリュー高かったのかもしれない。 あとは見つけた時に超クールだと思った hyst というツールについても軽く紹介した。 hyst を作っている @winebarrel さんには miam や roadworker でもお世話になっています。 あと Quipper でも使われているみたいです。
  
</div>

      
    
      
        <div class="post-header-home">
  <h1 class="post-title-home">
    <a href="https://blog.yuyat.jp/post/stuff-to-get-response-time-with-curl/">curl でレスポンスタイムをシュッと取るヤツ</a>
  </h1>
  <p class="text-muted">Sep 27, 2016</p>

</div>
<div class="post-excerpt-home">
  以前 Qiita にcurl でサッと HTTP ベンチマークと書いたが、それをもうちょい簡単にやるために以下のようなコマンドを用意してみた。 #!/bin/sh curl -s -o /dev/null -w '%{time_starttransfer}\n' &quot;$@&quot; これを curlb という名前で $PATH の通ったところに置いておくと以下のようにできる。 $ curlb https://blog.yuyat.jp/ 0.067
  
</div>

      
    
      
        <div class="post-header-home">
  <h1 class="post-title-home">
    <a href="https://blog.yuyat.jp/post/tee2err/">標準エラー出力に tee するコマンド tee2err を作った</a>
  </h1>
  <p class="text-muted">Sep 26, 2016</p>

</div>
<div class="post-excerpt-home">
  GNU tee でも BSD tee でもできないので作りました。 yuya-takeyama/tee2err これは何か 標準入力を食わせると、標準出力と標準エラー出力に同じものを出力するだけのコマンドです。 $ echo foo | tee2err foo foo foo と 2 回出力されていますが、一方は標準出力に、もう一方は標準エラー出力に出力されています。 どういう時に使うか 標準入力からストリームを食わせるとなんらかの終端操作を行うようなツールと一緒に使います。 例えば 1 から 10 までの数列の総和を求める場合。 $ seq 10 | perl -ane '$i+=$_; END { print &quot;SUM: $i\n&quot;; }' SUM: 55 これはこれで特に問題ないですが、これに tee2err を組み合わせるとこのようになります。 $ seq 10 | tee2err | perl -ane '$i+=$_; END { print &quot;SUM: $i\n&quot;; }' 1 2 3 4 5 6 7 8 9 10
  
  <p class="text-right"><a href="https://blog.yuyat.jp/post/tee2err/">Continue Reading &rarr;</a></p>
  
</div>

      
    
      
        <div class="post-header-home">
  <h1 class="post-title-home">
    <a href="https://blog.yuyat.jp/post/serving-github-pages-through-reverse-proxy/">GitHub Pages を nginx のリバースプロキシ越しに配信する</a>
  </h1>
  <p class="text-muted">Sep 25, 2016</p>

</div>
<div class="post-excerpt-home">
  このブログは以前の記事にも書いた通り、GitHub Pages から配信しています。 そしてさらに、前段に nginx のリバースプロキシを置いた構成になってます。 何故リバースプロキシを利用するか はっきり言って普通に考えたら無駄感はありますが、良い点をいくつか挙げてみます。 Zone apex domain を使用することができる GitHub Pages は CNAME による Custom domain に対応していますが、CNAME では通常 Zone apex domain に対応することができません。 リバースプロキシを利用することで、ドメインの A レコードにリバースプロキシを指定し、その upstream に GitHub Pages の URL を指定することで、対応することができます。 (このブログはご覧の通り Zone apex domain ではないですが、そのうちそっちにもページを作るつもりです) Custom domain でも HTTPS を使用することができる GitHub Pages はデフォルトでは USERNAME.github.io ドメインが割り当てられ、HTTPS で配信されます。 ですが、CNAME を使った場合は HTTP となってしまい、HTTPS を利用する方法は GitHub からは提供されていません。 Let&rsquo;s Encrypt を使えばセットアップは簡単です。 アクセスログをちゃんと取得できる GitHub でもリポジトリの Graphs -&gt; Traffic を見るとある程度わかりますが、nginx で好きなログを残せるようになります。 設定手順
  
  <p class="text-right"><a href="https://blog.yuyat.jp/post/serving-github-pages-through-reverse-proxy/">Continue Reading &rarr;</a></p>
  
</div>

      
    
      
        <div class="post-header-home">
  <h1 class="post-title-home">
    <a href="https://blog.yuyat.jp/post/auto-renew-letsencrypt-cert-keys-with-ansible-and-certbot/">Let&#39;s Encrypt の証明書を Ansible と certbot で Nginx にインストール &amp; 自動更新</a>
  </h1>
  <p class="text-muted">Sep 19, 2016</p>

</div>
<div class="post-excerpt-home">
  これもリニューアルネタです。 やりたいこと Let&rsquo;s Encrypt の証明書を Ansible でインストールする その後の証明書の更新も自動で行うようにする その設定もやはり Ansible で行う 前提とする環境 Ubuntu 16.04 だと certbot が apt-get でインストールできますが、それ未満だと certbot-auto というコマンドを手動でインストールする必要があります。 中身はほぼ同じだと思いますが、そちらについての説明はしません。 Ubuntu 16.04 Ansible 2.1.1.0 nginx 1.10.1 手順 certbot のインストール certbot とは Let&rsquo;s Encrypt の証明書の取得や更新を自動化するためのコマンドラインツールです。 こんな感じの playbook でインストールします。 - name: install certbot apt: name=letsencrypt state=present update_cache=yes 証明書の取得 certbot は Automated Certificate Management Environment (ACME) というプロトコルにより証明書の取得を行います。 これは、Let&rsquo;s Encrypt のサーバが証明書を取得しようとしているドメインのある URL にアクセスし、ちゃんとレスポンスを返すことができるかチェックするというものです。 そのため事前に nginx 等の Web サーバを起動して、インターネットからリーチできる状態にしておく必要があります。 (--standalone オプションを使えば certbot 自身が
  
  <p class="text-right"><a href="https://blog.yuyat.jp/post/auto-renew-letsencrypt-cert-keys-with-ansible-and-certbot/">Continue Reading &rarr;</a></p>
  
</div>

      
    
      
        <div class="post-header-home">
  <h1 class="post-title-home">
    <a href="https://blog.yuyat.jp/post/auto-deploy-hugo-to-github-pages-with-circleci/">Hugo で作ったサイトを CircleCI で GitHub Pages に自動デプロイ</a>
  </h1>
  <p class="text-muted">Sep 19, 2016</p>

</div>
<div class="post-excerpt-home">
  Hugo は Jekyll と違って、GitHub Pages に push しても勝手にページ生成はされません。 どうにかして自分で Hugo を実行し、それで生成されたファイルを push する必要があります。 このブログを構築するにあたって、CircleCI でビルドして自動デプロイする手順がまとまったので公開します。 なお、このブログはカスタムドメインを使用していますが、それについての説明はこの記事ではしません。 前提とする環境 Hugo Ver. 0.16 概要 以下のような環境・手順で自動デプロイが行われるようにします。 記事のソースは master ブランチに push する GitHub Pages 用のブランチには gh-pages を使う master ブランチが更新された時に gh-pages が自動的に更新される セットアップ手順 対象ブランチの設定 当然ですがリポジトリを準備します。 そしてリポジトリの Settings から GitHub Pages の Source として gh-pages を選択します。 ただし、gh-pages ブランチがない状態だと選択できないと思うので、その場合は手動でブランチだけ作るか、CircleCI によるデプロイが行われた後で行うと良いでしょう。 デプロイキーの用意 CircleCI は CI 対象のリポジトリを登録する時に、自動的に対象リポジトリの SSH キーを生成します。 が、これは read-only なので、今回の様に CircleCI から GitHub に push したい場合は使えません。 なので手動で生成し、登録する必要があります。 鍵の生成については GitHub のドキュメント等を参照してください。 Generating a new SSH key 生成したら GitHub リポジトリの Settings -&gt; Deploy keys -&gt; Add deploy key と進み、Key には生成した公開鍵ファイルの中身を貼り付け、Allow write access にチェックを入れてください。 また、CircleCI 側には秘密鍵を登録します。 Project Settings -&gt; SSH Permissions -&gt; Add SSH Key と進み、hostname には github.com、Private Key には秘密鍵の中身を貼り付けてください。 これで github.com へのデプロイ時にはこの鍵ファイルが使われるようになります。 デプロイスクリプトの用意 circle.yml は以下のようなものを準備します。 master ブランチが更新された時はデプロイ用のスクリプトを実行するようになっています。 dependencies: pre: - wget https://github.com/spf13/hugo/releases/download/v0.16/hugo_0.16-1_amd64.deb - sudo dpkg -i hugo_0.16-1_amd64.deb test: override: - &quot;true&quot; deployment: production: branch: master commands: - ./scripts/deploy_production.sh デプロイスクリプトは以下のようにします。 これを scripts/deploy_production.sh という名前で保存して、忘れずに chmod +x しておきましょう。 設定部分は環境変数でセットするようにしてあるので、コピペそのままで使えると思います。 #!/bin/bash -eux if [ -z &quot;${GIT_USER_NAME}&quot; ]; then echo &quot;Please set an env var GIT_USER_NAME&quot; exit 1 fi if [ -z &quot;${GIT_USER_EMAIL}&quot; ]; then echo &quot;Please set an env var GIT_USER_EMAIL&quot; exit 1 fi GIT_REPO=&quot;git@github.com:${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}.git&quot; git submodule init git submodule update remote=`git ls-remote --heads 2&gt; /dev/null | grep gh-pages || true` if [ -n &quot;$remote&quot; ]; then git clone -b gh-pages &quot;${GIT_REPO}&quot; public rm -rf public/* else git init public cd public git checkout -b gh-pages git remote add origin &quot;${GIT_REPO}&quot; cd ..
  
  <p class="text-right"><a href="https://blog.yuyat.jp/post/auto-deploy-hugo-to-github-pages-with-circleci/">Continue Reading &rarr;</a></p>
  
</div>

      
    
      
        <div class="post-header-home">
  <h1 class="post-title-home">
    <a href="https://blog.yuyat.jp/post/brand-new-blog/">ブログを Hugo でリニューアルした</a>
  </h1>
  <p class="text-muted">Sep 19, 2016</p>

</div>
<div class="post-excerpt-home">
  長年 Wordpress を使ってきたけどいい加減辛くなってきたので Hugo に移行しました。 過去ブログのデータ移行については過去に何度も挫折していて、結局リバースプロキシを使っていい感じに振り分けることにしました。 以前の記事 URL は基本的に全て生きているはずです。 コメントとかはできませんが。 新ブログは GitHub Pages からリバースプロキシを介して配信しています。 Let&rsquo;s Encrypt で SSL 化し、ついでに Nginx も HTTP2 化したので、その辺のネタはそのうちに書いていければと思ってます。 あと、テーマは @chibicode さんの hugo-theme-shiori をカスタマイズして使っています。 今後ともよろしくお願いします。
  
</div>

      
    
    <hr>
    <div class="home-read-more">
      <a href="https://blog.yuyat.jp/post/" class="btn btn-primary btn-block btn-lg">View All 10 Articles →</a>
    </div>
  </div>
  <div class="col-sm-4">
    

<h3>
  Author
</h3>

<p>
  <div class="media">
    
    <img src="//www.gravatar.com/avatar/33685a20ded68e6861bec3c1bd7f0870?s=100" alt="Yuya Takeyama" class="pull-left">
    
    
    <div class="media-body">
      <h4 class="media-heading">Yuya Takeyama</h4>
    </div>
    
  </div>
</p>



<p><a href="https://twitter.com/yuya_takeyama" class="twitter-follow-button" data-show-screen-name="false" data-show-count="true" data-dnt="true" data-size="large">Follow @yuya_takeyama</a></p>


  </div>
</div>
      <div class="row footer">
        <div class="col-sm-12 text-center">
          <footer>

&copy; 2015.
Built with <a href="http://gohugo.io/">Hugo</a> (0.16) and
<a href="https://github.com/chibicode/hugo-theme-shiori">Shiori Theme</a>.

</footer>

        </div>
      </div>
    </div>
    <script src="https://blog.yuyat.jp/javascripts/shiori.js"></script>
    


<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

<script>hljs.initHighlightingOnLoad();</script>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-12392004-1', 'auto');
  ga('send', 'pageview');

</script>


  </body>
</html>

