<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Born Too Late</title>
    <link>https://blog.yuyat.jp/post/</link>
    <description>Recent content in Posts on Born Too Late</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Mon, 02 Dec 2019 03:15:00 +0900</lastBuildDate>
    <atom:link href="https://blog.yuyat.jp/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>AirPods Pro を使って英会話の訓練をしながら Kubernetes をはじめとするあらゆるテクノロジーについて学べるすごい学習法</title>
      <link>https://blog.yuyat.jp/post/learn-kubernetes-in-english/</link>
      <pubDate>Mon, 02 Dec 2019 03:15:00 +0900</pubDate>
      
      <guid>https://blog.yuyat.jp/post/learn-kubernetes-in-english/</guid>
      <description>

&lt;p&gt;約 1 年ぶりにブログを書くにあたって、めちゃくちゃ釣りっぽいタイトルにしてみました。 (昨日すでに&lt;a href=&#34;https://blog.yuyat.jp/post/becoming-an-engineering-manager/&#34;&gt;別の記事&lt;/a&gt;が出ていますが、書き始めたのはこちらが先でした)&lt;/p&gt;

&lt;p&gt;この記事は &lt;a href=&#34;https://amzn.to/33xf90B&#34;&gt;AirPods Pro&lt;/a&gt; のアフィリエイトによる小銭稼ぎ (まぁ今現在 Amazon では売り切れてるけど) と、僕のあらゆる物事に対する学習・訓練に対する考え方をまとめて、識者からフィードバックを得ることを目的にしています。&lt;/p&gt;

&lt;p&gt;で、その両方を達成する上で都合がいいので、AirPods Pro を使ったシャドーイングを題材に書いてみようと思います。学習に関する考え方についてはいかにもわかってる風に書きますが、素人が適当なことを言っているだけなので、暇つぶし程度にご笑覧いただければ幸いです。&lt;/p&gt;

&lt;h2 id=&#34;tl-dr&#34;&gt;tl; dr&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://amzn.to/33xf90B&#34;&gt;AirPods Pro&lt;/a&gt; は英語をはじめあらゆることを学ぶためにめちゃくちゃコスパがいいので自分の学習体験への投資だと思って買いましょう&lt;/li&gt;
&lt;li&gt;英会話の訓練にはシャドーイングがとても重要なのでとにかく量をこなしましょう&lt;/li&gt;
&lt;li&gt;シャドーイングをする上ではコンテンツに興味を持てることが重要なので、ソフトウェアエンジニアなら Podcast でソフトウェアエンジニアリングに関するものを聞きまくりましょう&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;table-of-contents&#34;&gt;Table of contents&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#airpods-pro-を使ったシャドーイングのやり方&#34;&gt;AirPods Pro を使ったシャドーイングのやり方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#私について&#34;&gt;私について&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#シャドーイングとは-それで何が得られるか&#34;&gt;シャドーイングとは、それで何が得られるか&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#聞き流すだけでは何故ダメか-僕の学習の考え方&#34;&gt;聞き流すだけでは何故ダメか、僕の学習の考え方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#効果的にシャドーイングをやるために意識していること&#34;&gt;効果的にシャドーイングをやるために意識していること&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#シャドーイングを継続するためにあると良いもの&#34;&gt;シャドーイングを継続するためにあると良いもの&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#僕が聴いている-podcast-ステーション&#34;&gt;僕が聴いている Podcast ステーション&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#まとめ&#34;&gt;まとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;airpods-pro-を使ったシャドーイングのやり方&#34;&gt;AirPods Pro を使ったシャドーイングのやり方&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;AirPods Pro を買う&lt;/li&gt;
&lt;li&gt;自分が興味を持っている事柄に関する Podcast のステーションを見つけて購読する&lt;/li&gt;
&lt;li&gt;面白そうなものを聞きながら、聞こえた内容をそのまま話す (シャドーイング)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;簡単ですね。&lt;/p&gt;

&lt;h2 id=&#34;私について&#34;&gt;私について&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2015 年 9 月から、グローバルなビジネスを展開する企業の日本オフィス勤務&lt;/li&gt;
&lt;li&gt;オフィス内での口頭の会話は日本語がほとんどだが、Slack では英語の割合が 30 ~ 40% ぐらい (多分)、GitHub 上ではほとんど英語を読み書きしている&lt;/li&gt;
&lt;li&gt;10 月からマネージャーになり、チームには日本語が苦手なメンバーもいるためミーティングや 1 on 1 を英語でやったりもしている&lt;/li&gt;
&lt;li&gt;TOEIC は 3 年前に 770 を取って以降受けていないし今はあまり興味ない (&lt;a href=&#34;https://docs.google.com/spreadsheets/d/1Hhcjnz_pEFkoA5whzoaM9tTekfTL355yMkoTmeCqLh0/edit?usp=sharing&#34;&gt;TOEIC スコアの履歴&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ソフトウェア関係の仕事をしている都合上英語を学習するモチベーションはもともとあったものの、マネージャーになってからは英語の必要性も上がり、より高まっている感じです。&lt;/p&gt;

&lt;p&gt;今の会社に入ってしばらくは TOEIC のスコアはほとんど変わっていない (むしろ下がっている) ですが、シャドーイングを始めてからは自分の中にブレイクスルーを感じているので、是非共有したいと思いました。&lt;/p&gt;

&lt;p&gt;TOEIC スコアについてはめちゃくちゃ高いわけではないですし、むしろグローバル企業で働く上では低すぎるだろ、っていう罵声も飛んできそうですが、一方で日本人の平均からすると普通に高い範囲でもあるので、例えば 600 ぐらいの人だと「自分には参考にならない話だ」と思う人もいそうですが、自分のレベルにあった教材さえ見つけられればいくらでも応用できる感じに書いているつもりなので、良ければもう少しお付き合いください。&lt;/p&gt;

&lt;h2 id=&#34;シャドーイングとは-それで何が得られるか&#34;&gt;シャドーイングとは、それで何が得られるか&lt;/h2&gt;

&lt;p&gt;シャドーイングというのは一般的な英語学習の訓練メソッドです。詳細はググってもらえればいくらでも出てきます。&lt;/p&gt;

&lt;p&gt;僕としては以下が得られると思っています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;リスニング力&lt;/li&gt;
&lt;li&gt;発音&lt;/li&gt;
&lt;li&gt;ボキャブラリーや表現の幅&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;リスニング力については間違い無いでしょう。Podcast でやる場合、話しては必ずしもネイティブではなく、中には訛りがきつい人もいますが、英語というのはそういう訛りも含めて英語だと考えているので、多様な英語に慣れておくことで実世界でも役にたつと考えています。&lt;/p&gt;

&lt;p&gt;一方で発音については、Podcast を教材にすることには批判もありそうです。本来の英語からすれば間違った発音で話されているものも真似することになるので、間違って覚えてしまう可能性もありそうです。とはいえそもそも英米で発音が違ったりということもあるし、そういったものも含めて真似することで違いが理解できるという面もあると思うので、僕は割り切って気にせずやっています。何もしないよりは絶対に得るものがある。&lt;/p&gt;

&lt;p&gt;ボキャブラリーについては、新たに知ることもそうですが、知識としては知っているけど自分で使えるほどでもないものを定着させる効果も大きいのではと思っています。例えば話し言葉ではざっくり話すときに kind of とか like とかよく使いますし、仮定の話をするときは assume if とか presumably とか使いますが、僕はもともとこれらの言葉を使ってきませんでした。何故なら最低限の伝えたい情報や事実を伝えるだけなら、これらは無くても何とかなるから。でも実際に英会話をする上では、こういったものも含めて細かい表現をたくさん使えるとより細かいニュアンスも含めて伝えられるでしょう。&lt;/p&gt;

&lt;h2 id=&#34;聞き流すだけでは何故ダメか-僕の学習の考え方&#34;&gt;聞き流すだけでは何故ダメか、僕の学習の考え方&lt;/h2&gt;

&lt;p&gt;(この辺から素人の怪しげな理論じみた話が多めになるのでご注意ください)&lt;/p&gt;

&lt;p&gt;テレビやラジオでは聞き流すだけを謳う英語学習教材の CM がよく流れていると思います。が、僕はこれを全く信用していません。聞くだけなのでシャドーイングより効果が低いのは当たり前かもしれませんが、そもそも僕が思う学習の考え方とイメージが根本的に異なるというのが理由です。&lt;/p&gt;

&lt;p&gt;僕が物事の学習だったり、スキルの訓練において考えているのは以下についてです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;量と質&lt;/li&gt;
&lt;li&gt;インプットとアウトプット&lt;/li&gt;
&lt;li&gt;ボトムアップとトップダウン&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これはそんなに変わった考え方ではないと思いますが順に見ていきます。&lt;/p&gt;

&lt;h3 id=&#34;量と質&#34;&gt;量と質&lt;/h3&gt;

&lt;p&gt;これはまぁいいでしょう。学習成果は量 x 質で決まります。質の低い学習ばかりをやっていてもダメですが、質にこだわるあまり量をこなさないのもダメです。学習・訓練の質の良し悪しを知るにはまずは量をこなすことが大事なので、特に何か新しいことを始めるときにはまず量をこなし、その後で質を上げるためのことを考えていきます。この辺は &lt;a href=&#34;https://twitter.com/t_wada&#34;&gt;@t_wada&lt;/a&gt; さんがよく言っている&lt;a href=&#34;https://www.slideshare.net/t_wada/testing-casual-twada/61&#34;&gt;「量は質に転化する」&lt;/a&gt;という話に強く影響を受けている気がします。&lt;/p&gt;

&lt;h3 id=&#34;インプットとアウトプット&#34;&gt;インプットとアウトプット&lt;/h3&gt;

&lt;p&gt;これに関しては大学時代に所属していた軽音サークル、その友人、そして楽器から学んだと思ってます。人によっては中学校での部活動とか、習い事の中で学ぶのかもしれませんが、僕は中学は水泳部で幽霊部員をやり、高校は帰宅部で虚無をやっていたので、大学生の、それも 4 年生ごろにようやく言語化できたと記憶しています。&lt;/p&gt;

&lt;p&gt;(ここから楽器の練習の例えも始まりさらに怪しい感じになります)&lt;/p&gt;

&lt;p&gt;楽器の練習を僕は以下の 2 つに区別していました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;できるようになるための練習 (インプット)&lt;/li&gt;
&lt;li&gt;するための練習 (アウトプット)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;どういうことか、ギターでメタルの速弾きギターソロを練習することを例に考えてみましょう。&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/hb5QaCfm7bg&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;ギターの速弾き、さらに単純化してギターで速いフレーズを弾くには少なくとも以下が必要です。 (右利きと仮定)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;右手首で素早くピッキングできること&lt;/li&gt;
&lt;li&gt;左手の指を速く動かしてフレットを抑えられること&lt;/li&gt;
&lt;li&gt;その両方をシンクロできること&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;200 BPM の十六分音符の曲を弾くには、大前提として右手首でのピッキングをそれ以上の速さでできなくては無理です。右手でどんなに頑張っても 190 BPM が限界、という人は右手だけの練習をしてもう 10 BPM 分以上のキャパシティを得ることが必要です。&lt;/p&gt;

&lt;p&gt;ですが、仮に右手だけ 500 BPM まで弾けようになったっとしても、左手の限界が 190 BPM だとすると、190 BPM 以上のフレーズは当然弾けません。左手に特化した練習を行う必要があるでしょう。&lt;/p&gt;

&lt;p&gt;つまり、両手ともにバランスよく練習して初めてアウトプットを最大化できるわけです。&lt;/p&gt;

&lt;p&gt;ここでは右手・左手で独立した、ある種筋トレ的な練習のことを「インプット」とします。200 BPM でフレーズを弾けるために最小限必要なキャパシティをフィジカルに得る必要があります。それが「できるようになるための練習」。&lt;/p&gt;

&lt;p&gt;が、それだけではダメです。&lt;/p&gt;

&lt;p&gt;実際にはその 2 つの要素を綺麗にシンクロさせる必要があります。右手・左手のどちらも 200 BPM で動かせていたとしても、フレットを押さえてピッキングしてという動作がシンクロしていないと正しく音が出ないので、ひどいとギターソロとして成立しなくなります。その組み合わせを正しくシンクロさせる練習をここでは「アウトプット」と呼びます。両方 200 BPM 弾ける時点でできる素養はあるがまだできていないことを実際に「するための練習」。&lt;/p&gt;

&lt;p&gt;ここで読んで違和感を覚える人もいると思います。ギターソロを弾く上で右手・左手をシンクロさせるための練習についても、それを含めた曲全体を弾く上では「できるようになるための練習 (インプット)」として捉えられるのではないか、と。逆に右手のインプットに関しても、前提として筋肉をその速さで動かされることがあり、それをピックを指で持って弦を弾きながらでもできるようにする、というのは「するための練習 (アウトプット)」と呼べるのではないか、と。&lt;/p&gt;

&lt;p&gt;これは僕としてはどちらとも捉えることができると思います。そもそもその二つは明確にゼロイチで区別できるものではないと思います。どんな練習もインプット性・アウトプット性というのがある程度混ざり合ったものになり得ます。が、今現在の自分自身にとってこの学習方法・練習方法はそのどちらなのか、またどれぐらいの割合なのか、というのを意識すると、今自分がやっていることの質を判断する上では重要なヒントになるんじゃないでしょうか。&lt;/p&gt;

&lt;h3 id=&#34;ボトムアップとトップダウン&#34;&gt;ボトムアップとトップダウン&lt;/h3&gt;

&lt;p&gt;これは正直インプットとアウトプットの話とかなり似ているかもしれません。僕としてはそれをさらに一歩引いた目線からこれらを捉えたものとして理解しています。&lt;/p&gt;

&lt;p&gt;さっきのギターソロの例を続けます。ギターソロは曲全体を弾くことから見ればほんの一部ですし、一曲を弾くことすらライブのステージに立って客を沸かせる上ことからすればこれも一部と考えられますし、ヘヴィメタルを通じて世界に破壊と殺戮をもたらすことを目標とするなら一回一回のライブもその一部ということになります。まぁそこまでいくと話がややこしくなるので一旦は一曲を弾くことというレベルで考えていきます。&lt;/p&gt;

&lt;p&gt;一曲の中から見ればギターソロであったり、その中の特徴的なフレーズ・メロディや、ギターリフというのは個別の要素です。これらを個別に練習することはボトムアップ式の練習です。最初はギターリフがかっこよくて「オッ」と思ってそれをコピーして一旦満足し、せっかくだからギターソロもコピーしたり、バンドでやるためにコーラスを練習したりもすることでしょう。&lt;/p&gt;

&lt;p&gt;そういったボトムアップからの積み上げ式の練習も、個別の要素を磨き上げる意味では良いのですが、トップダウンからの練習もやってみないと全体感を失います。ソリッドで強烈なギターリフがあるからこそ流麗なギターソロのメロディが更に映え、それに呼応するようにメタルヘッズは拳をあげ、声をあげて泣くものです。&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/Omt4-eW412A&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;もっと言えばギターリフやギターソロのようなわかりやすい要素以外のあらゆる細かい要素が曲全体のストーリーや世界観を作り上げるのに役割を果たしているものです。それらが持つ意味というのはそれら自身が持つのではなく、全体の構造の中にあって初めて成り立つものだったりするわけです。&lt;/p&gt;

&lt;p&gt;この辺は昔 &lt;a href=&#34;https://twitter.com/amachang&#34;&gt;@amachang&lt;/a&gt; さんがブログに書いた&lt;a href=&#34;https://amachang.hatenablog.com/entry/20080204/1202104260&#34;&gt;遅延評価勉強法&lt;/a&gt; の影響を強く受けていると思います。&lt;/p&gt;

&lt;h3 id=&#34;聞き流すだけの英語学習ではな何故ダメだと思うか&#34;&gt;聞き流すだけの英語学習ではな何故ダメだと思うか&lt;/h3&gt;

&lt;p&gt;ここまで読んだ方ならもう完全に理解していると思いますが、念の為書きます。&lt;/p&gt;

&lt;p&gt;「聞き流す」という行為は量をこなす上ではやりやすく、そこは非常に魅力的だと思います。が、質という点においては疑問があります。&lt;/p&gt;

&lt;p&gt;聞き流すという行為はインプット性が高い学習だと思うので、アウトプット的なこともしていく必要があるでしょう。正しい発音を繰り返し聞いて知ったあと、それを自分でも再現していく練習をしていく必要があります。&lt;/p&gt;

&lt;p&gt;また、英語を聞き流すのは、実際に英会話を行うことから見ればボトムアップ的な練習に過ぎないので、トップダウン的に練習するには、間違ってていても嘘でも拙くてもいいから実際に英会話の機会を持つ必要があります。聞き流すこと自体にも価値があるとしても、それ「だけ」でできるようになることは考えにくいことです。&lt;/p&gt;

&lt;p&gt;まぁ実際は&lt;a href=&#34;https://www.espritline.jp/speedlearning/&#34;&gt;英語をマネて口から出す&lt;/a&gt;ということをスピードラーニングの公式も書いているので、聞き流すだけはダメです！&lt;/p&gt;

&lt;h2 id=&#34;効果的にシャドーイングをやるために意識していること&#34;&gt;効果的にシャドーイングをやるために意識していること&lt;/h2&gt;

&lt;p&gt;シャドーイングで得られるものについては、リスニング力、発音、ボキャブラリーや表現の幅という 3 点を序盤で挙げました。ですが、これらの全てを一気に向上させるのは難しいと思うので、実際はどれか一つずつを意識するのが良いと考えています。&lt;/p&gt;

&lt;p&gt;例えば、早口で聞くので精一杯な教材であれば、聞く方で脳内の CPU を使い切り、発音や表現に意識を持っていくのは難しいでしょう。ちゃんと発音できなかったり、内容までちゃんと理解できてないとしてもまずはリスニング力を鍛えることができるはずです。&lt;/p&gt;

&lt;p&gt;最初は聞くので精一杯だとしても、同じ教材を繰り返し聞いたり、もしくは同じレベル感の別の教材で訓練を積むことで、脳内 CPU の 80% ぐらいでも聞き取ることができるようになれば、その意識リソースを発音に向けることができるようになります。僕の場合は自分のキャパシティよりもゆっくり目の教材であれば聞く方はほとんど無意識に近いレベル (と少なくとも自分では思っている) で発音や表現の方に集中することができるようになってきたと感じています。&lt;/p&gt;

&lt;p&gt;教材の速さにもよりますが、聞いてそれを発音して、というのは結構すぐに無意識に近いレベルでできるようになりました。ここで意外と難しいのが、ちゃんと内容を理解することです。これも話している内容のレベルや、表現の難しさにもよりますが、学校で習ったことのある慣用表現がちゃんと使われているんだなと気づいたり、聞いたことはなくてもなんとなく想像できる表現というのが聞き取れ、想像を働かせる余裕も出てきます。&lt;/p&gt;

&lt;h2 id=&#34;シャドーイングを継続するためにあると良いもの&#34;&gt;シャドーイングを継続するためにあると良いもの&lt;/h2&gt;

&lt;p&gt;ここに挙げているものは欠けていてもできなくはないと思いますが、僕は意識が低いので、なるべく継続しやすい状況を作ることを意識しています。&lt;/p&gt;

&lt;h3 id=&#34;興味を持てるコンテンツをなるべくたくさん見つけること&#34;&gt;興味を持てるコンテンツをなるべくたくさん見つけること&lt;/h3&gt;

&lt;p&gt;例えば初学者だといかにも学習向けの教材を使う必要があるかもしれませんが、そこより先にいる人であれば Podcast を聞くのがいいでしょう。私は IT やテクノロジー関連の Podcast を聞いて、時には仕事に便利な情報も得ながらやっています。英語学習以外の意味でもメリットが大きいのでこれは大きなモチベーションになっています。&lt;/p&gt;

&lt;p&gt;オススメのステーションについてはあとで紹介していきます。&lt;/p&gt;

&lt;h3 id=&#34;英語学習のモチベーションを維持できる環境に身を置く&#34;&gt;英語学習のモチベーションを維持できる環境に身を置く&lt;/h3&gt;

&lt;p&gt;外資系企業だったり、グローバルにビジネスを展開している企業に入社するのが良いでしょう。国内の企業でドメスティックな事業をやったことがない人にとってはハードルに感じるかもしれませんが、会社によっては日本オフィス内は日本語での会話がほとんどで、読み書きを調べながらできれば十分、TOEIC スコアでいうと 600 程度でもなんとかなる、という会社もあると思います。 (僕が勤めっている会社もそんな感じです)&lt;/p&gt;

&lt;h3 id=&#34;airpods-pro-等の便利なイヤホンを買っていつでもどこでもシャドーイングできるようにする&#34;&gt;AirPods Pro 等の便利なイヤホンを買っていつでもどこでもシャドーイングできるようにする&lt;/h3&gt;

&lt;p&gt;必ずしも &lt;a href=&#34;https://amzn.to/33xf90B&#34;&gt;AirPods Pro&lt;/a&gt; である必要はないですが、AirPods Pro を推すポイントは以下の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;とにかく軽いし邪魔にならないのでどこでも持っていける&lt;/li&gt;
&lt;li&gt;Noise Cancellation を利用すれば電車内でも快適にシャドーイングできる&lt;/li&gt;
&lt;li&gt;Transparency モードにすれば外で歩きながらでもある程度安全にシャドーイングできる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AirPods Pro といえばとにかく Noise Cancellation が素晴らしいのは皆さんご存知でしょう。僕も Bose のノイズキャンセリングヘッドホンを以前使っていてそれも特に問題なかったのですが、AirPods Pro はより自然な感じがしました。電車内だとかなり静かに感じます。自分で出している声はよく聞こえるので、普通の話し声よりもかなり小さい声でやってもちゃんとシャドーイングできます。奇異の目で見てくる人もいますが、普通の話し声より小さければ迷惑は掛からないはずなので気にせずやっていきましょう。英語学習を阻害する最大の壁は羞恥心だと思います。&lt;/p&gt;

&lt;h3 id=&#34;歩きながらシャドーイングする&#34;&gt;歩きながらシャドーイングする&lt;/h3&gt;

&lt;p&gt;個人的には通勤や散歩で街を歩きながらずっとシャドーイングしています。平日でも 1 日 30 分ぐらいは余裕でやってますし、休日は 2 ~ 3 時間ぐらいやってます。ネイティブが何故英語を上手に話せるかというと 1 日中それを使って会話しているからです。シャドーイングは濃度としては会話未満かもしれませんが、それならなおさら量をこなすことは重要じゃないでしょうか。すれ違いざまに奇異の目で見てくる人もいますが、やはり英語学習を阻害する最大の壁は羞恥心ということにして強い気持ちでやっていきましょう。職質されたら勝ちぐらいの気持ちでやってますが、まだ一度もされてません。&lt;/p&gt;

&lt;h3 id=&#34;散歩しやすく-散歩が楽しい街に住む&#34;&gt;散歩しやすく、散歩が楽しい街に住む&lt;/h3&gt;

&lt;p&gt;これに関しては、僕が今の街に住み始めたのは 3 年以上前のことなので、もちろんシャドーイングのために引っ越したわけではありません。シャドーイング散歩を始めてみて、改めて散歩が楽しい街だと思いましたが、これはたまたまです。近所に大きめの寺社仏閣が複数あるので、敷地内なら車や自転車に轢かれる心配はありませんし、夜や早朝は人通り・車通り共にかなり少ないので、Transparency モードで歩いていて危険を感じることはほぼありません。あとはランニングによく使われる川沿いの歩道もあったり。&lt;/p&gt;

&lt;p&gt;とはいえ安全性は重要ですし、僕としては責任取れないのでくれぐれも気をつけてください。シャドーイングとは関係ないけど、今日たまたま見たこの記事は、確かになと思いました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://anond.hatelabo.jp/20191130203404&#34;&gt;真夜中のランナーに告ぐ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;お願いだから､反射材やライトも付けず､真っ黒なジャージを着て､音楽を聞きながら走るのはやめてくれ!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;まだ届いてないけど早速これを買いました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://amzn.to/2L8jGQQ&#34;&gt;Achy JP 反射アームバンド 蛍光反射バンド 伸縮性素材 反射バンド 超蛍光 超反射 視認性抜群 事故防止 4個セット マジックバンド式 蛍光色&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;あとは別にジムのランニングマシーンを歩きながらとかでも、続けられるなら良いのではないでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;僕が聴いている-podcast-ステーション&#34;&gt;僕が聴いている Podcast ステーション&lt;/h2&gt;

&lt;h3 id=&#34;software-engineering-daily-https-softwareengineeringdaily-com&#34;&gt;&lt;a href=&#34;https://softwareengineeringdaily.com/&#34;&gt;Software Engineering Daily&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;クラウド、オープンソース、セキュリティ、ブロックチェーンなど様々なトピックについて、毎回 1 時間ほどのトピックが平日毎日配信されています。アーカイブも数年分あるので、この辺の分野に興味がある人的に面白い回がたくさんあると思います。&lt;/p&gt;

&lt;p&gt;モバイルアプリを入れると事前にダウンロードしたり、タグやキーワードでの検索も手軽にできるのでおすすめです。&lt;/p&gt;

&lt;p&gt;個人的に好きな回はこの辺です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://softwareengineeringdaily.com/2017/03/29/failure-injection-with-kolton-andrus/&#34;&gt;Failure Injection with Kolton Andrus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://softwareengineeringdaily.com/2019/04/23/observability-engineering-with-james-burns/&#34;&gt;Observability Engineering with James Burns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://softwareengineeringdaily.com/2017/03/31/webassembly-with-brendan-eich/&#34;&gt;WebAssembly with Brendan Eich&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://softwareengineeringdaily.com/2019/04/26/cloud-with-eric-brewer/&#34;&gt;Cloud with Eric Brewer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://softwareengineeringdaily.com/2018/11/02/scaling-lyft-with-matt-klein/&#34;&gt;Scaling Lyft with Matt Klein&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://softwareengineeringdaily.com/2018/01/13/the-gravity-of-kubernetes/&#34;&gt;The Gravity of Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回によっては早口だったりもしますが、全体的にはゆったり目で平易な英語を話してくれている印象です。最初は非ネイティブ向けにそうしているのかとも思いましたが、早口なやつは早口なのでちょっと狙いはよくわかってません。あとはゲストが非ネイティブな時はゆっくり目になる傾向にある気もしてます。&lt;/p&gt;

&lt;p&gt;基本的に雑談はあまりなく、ずっと真面目に話しているので、ボキャブラリー的には限られていますが、人によっては退屈に感じるかもしれません。&lt;/p&gt;

&lt;h3 id=&#34;kubernetes-podcast-from-google-https-kubernetespodcast-com&#34;&gt;&lt;a href=&#34;https://kubernetespodcast.com/&#34;&gt;Kubernetes Podcast from Google&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;こちらは週に 1 回の配信ですが、文字通り毎回 Kubernetes の話をします。&lt;/p&gt;

&lt;p&gt;オープニングは毎回雑談から始まって、最近見た映画の話とか色々するんですが、そこがやはり一番難しいと感じます。&lt;/p&gt;

&lt;p&gt;オープニングのあとはその週のニュースを紹介するパートがあり、これはやや早口。とはいえ最新情報が色々しれてとても便利です。&lt;/p&gt;

&lt;p&gt;ニュースが終わると本題に入り、ゲストと会話するというのがいつもの構成です。すでにアーカイブが 80 本ほどあるので、興味を持てるトピックについて聞くのが良いでしょう。&lt;/p&gt;

&lt;p&gt;Transcript もあったりなかったりします。&lt;/p&gt;

&lt;h3 id=&#34;the-new-stack-makers-https-thenewstack-io-podcasts-makers&#34;&gt;&lt;a href=&#34;https://thenewstack.io/podcasts/makers/&#34;&gt;The New Stack Makers&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;これは上記の 2 つに比べるとそんなに聴いてないですが、GitOps や Spinnaker といった CD 周りのツールの話題があることからリーチしました。&lt;/p&gt;

&lt;h3 id=&#34;talk-python-to-me-https-talkpython-fm&#34;&gt;&lt;a href=&#34;https://talkpython.fm/&#34;&gt;Talk Python To Me&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;これは最近会社で進められて直っと聴いてるやつ。聴いた範囲ではスピードが今の自分にとってはいい感じなのと、機械学習周りのトピックもふーんとわかった気になれるので聴いていこうと思ってます。&lt;/p&gt;

&lt;h3 id=&#34;the-changelog-https-changelog-com-podcasts&#34;&gt;&lt;a href=&#34;https://changelog.com/podcasts&#34;&gt;The Changelog&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;これはテック系 Podcast 界においては古参の部類だと思いますが、いつの間にかトピックごとにステーションが細分化してました。Go Time という Go に関するトピックを扱うステーションを時々聴いててます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;いかがでしたか？&lt;/p&gt;

&lt;p&gt;このような根拠の怪しい情報を最後まで読みきったあなたは素晴らしい根気の持ち主です。そのエネルギーをシャドーイングに向ければ、英語なんていくらでも上達するでしょう。&lt;/p&gt;

&lt;p&gt;今すぐシャドーイング始めましょう！！！１１１&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SRE チームで Engineering Manager になって二ヶ月経っての心境など</title>
      <link>https://blog.yuyat.jp/post/becoming-an-engineering-manager/</link>
      <pubDate>Sun, 01 Dec 2019 00:22:00 +0900</pubDate>
      
      <guid>https://blog.yuyat.jp/post/becoming-an-engineering-manager/</guid>
      <description>

&lt;p&gt;この記事は &lt;a href=&#34;https://qiita.com/advent-calendar/2019/em2&#34;&gt;Engineering Manager vol.2 Advent Calendar 2019&lt;/a&gt; の 1 日目の記事です。&lt;/p&gt;

&lt;p&gt;2 日目は &lt;a href=&#34;https://twitter.com/sbntaminif&#34;&gt;taminif&lt;/a&gt; さんの&lt;a href=&#34;http://taminif.hatenablog.jp/entry/2019/12/02/011112&#34;&gt;マネージャーになったら身に付けたいファシリテーションスキル&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;ふわっとしたタイトルのゆる目の記事ですが、Engineering Manager としては新米ですし、Advent Calendar 的にもまだ初日なのでこれぐらいで許してください。&lt;/p&gt;

&lt;p&gt;まぁ一言でいうと「Engineering Manager は決して楽ではないけど楽しいぞ！」という感じです。&lt;/p&gt;

&lt;h2 id=&#34;engineering-manager-として置かれている状況&#34;&gt;Engineering Manager として置かれている状況&lt;/h2&gt;

&lt;p&gt;前提としてこんな感じですよ、というのを軽く書いておきますがここは読み飛ばしてもらっても大丈夫です。&lt;/p&gt;

&lt;h3 id=&#34;会社&#34;&gt;会社&lt;/h3&gt;

&lt;p&gt;イギリスでの創業から約 9 年、日本の大企業に買収されてから 4 年半ほど経ったベンチャー企業です。&lt;/p&gt;

&lt;p&gt;ビジネスは日本だけでなく東南アジアや南米にも展開しているグローバル企業で、それぞれの地域に開発者、プロダクトマネージャー、デザイナー、BizDev、カスタマーサポート等がいて、基本的にはそれぞれの国ごとのビジネスに従事しています。&lt;/p&gt;

&lt;h3 id=&#34;チーム&#34;&gt;チーム&lt;/h3&gt;

&lt;p&gt;僕が Engineering Manager をやっているのは Site Reliability Engineering (SRE) チームです。他の職種が基本的に国ごとのチームなのに対し、SRE チームは横断的に仕事をしています。 (横断的に仕事をしているのは SRE だけでもないですが)&lt;/p&gt;

&lt;p&gt;メンバー 5 人 + Engineering Manager で合計 6 名というチームで、メンバーには自分よりキャリアの長いベテランもいれば、海外から移住にしてきて基本的に英語で会話しているメンバーがいたりと、属性だけ取り出してみれば新人マネージャーにはちょっと難易度高めにも見えるかもしれません。 (あくまでも属性だけ切り取れば。実際には以前からの関係性もあるし、自分ができない部分は助けてもらうことで普通に楽しくやってます。それでも自分より経験・スキルのある人に対してどうマネージャーとしてのバリューを出していくかとか、母国語でない言語でどう正確にコミュニケーションを取るか、という難しさについては無いと言ったら嘘になるかなという感じ)&lt;/p&gt;

&lt;p&gt;あとは自分が Engineering Manager になった日と同時に新入社員が 2 人同時に入ったというのもなかなかチャレンジングでした。このことについてはあとでオンボーディングも絡めて書きます。&lt;/p&gt;

&lt;p&gt;一方で別オフィスにメンバーがいるわけではないので、地理的・タイムゾーン的に離れたメンバーをマネージすることはないですが、そっちのメンバーも採用していきたいなと個人的には考えたりもしています。&lt;/p&gt;

&lt;h3 id=&#34;自分&#34;&gt;自分&lt;/h3&gt;

&lt;p&gt;そもそも元は Web Developer で、SRE になったのは 2018 年の 4 月なので、SRE 歴約 1 年半。IT 系のビジネスを行う企業に入ってからは約 10 年ほど、今の会社は 2 社目で丸 4 年ほど在籍しています。&lt;/p&gt;

&lt;p&gt;Web Developer として Tech Lead 的なことはやってきていたのですが、マネージャーというのは完全に初めてです。評価とか怖い！&lt;/p&gt;

&lt;p&gt;また、他のメンバーは入社から 2 年未満という人が多い中で、入社から 4 年というのは会社全体で見てもかなりの古株になってしまいました。最近はそんなに入れ替わりが激しいわけでもないですが、やっぱり買収という形で exit を迎えると創業期から関わっていたメンバーとかは卒業していったりもあるので、そんなもんでしょう。というわけで会社のビジネスやプロダクト、そしてどんなチームでどんな人たちがどんな仕事をしているか、という情報については他のメンバーよりもかなりよく知っているつもりです。&lt;/p&gt;

&lt;h2 id=&#34;engineering-manager-として大変なこと&#34;&gt;Engineering Manager として大変なこと&lt;/h2&gt;

&lt;p&gt;前置きが長くなりましたがここからようやく本題です。&lt;/p&gt;

&lt;p&gt;Engineering Manager をやっている中で自分が大変だけど重要と思っている事柄についてとりとめなく書いていきます。&lt;/p&gt;

&lt;h3 id=&#34;結構技術のことを考えないといけない&#34;&gt;結構技術のことを考えないといけない&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;Engineering&amp;rdquo; Manager なんだから当たり前だろ！という声も聞こえてきそうですが、やはりいちメンバーに比べると技術からは遠ざかり、最新のニュースへのアンテナを高くする重要性も相対的には下がるのでは、とか思ったりもしていました。&lt;/p&gt;

&lt;p&gt;もちろん、Engineering Manager になるには前提としてある程度高い技術力が求められますが、それでも業務的にはピープルマネジメントみたいなところに時間を使う必要もあるわけなので。&lt;/p&gt;

&lt;p&gt;が、これはむしろ逆なのでは、というのが現時点での感想です。&lt;/p&gt;

&lt;p&gt;SRE チームとしての戦略を考える上では会社、周辺のチーム、SRE チーム自身が抱えている問題を正しく理解する必要があり、これは決して技術だけではないですが、深い洞察が求められます。&lt;/p&gt;

&lt;p&gt;あとこれは SRE という職種の性質上によるところもあるのかもしれませんが、そういった問題を基本的には技術の力で解決していく必要があります。&lt;/p&gt;

&lt;p&gt;そういった問題を考える上でありがたいのは先人の知恵です。&lt;a href=&#34;https://www.weblio.jp/content/%E8%AA%B2%E9%A1%8C%E5%85%88%E9%80%B2%E5%9B%BD&#34;&gt;課題先進国&lt;/a&gt;という言葉がありますが、それと同じように、Google とか Netflix みたいな先進的な企業は他の企業では直面しない先進的な課題にいち早く直面して、解決していく必要があります。例えば Google が Site Reliability Engineering という新たな方法論を生み出したのにはそういう背景があったのだなと、Engineering Manager になった今は前よりも強く思えますし、DevOps やクラウドの重要性が高まっている理由についても前より想像を働かせやすくなったと感じます。&lt;/p&gt;

&lt;p&gt;一方でそういった課題が今自分がいる状況にそのまま当てはめられるのか、というとそうとは限りません。今この瞬間がそうでないとして、将来問題になる可能性もならない可能性もあります。そういう状態でどういう技術や方法論を選択するか、またはしないのかという判断にはやはり高い技術力や知識が求められます (それ以外にもいっぱい求められると思いますけど)。&lt;/p&gt;

&lt;h3 id=&#34;management-と-lead-の不可分性&#34;&gt;Management と Lead の不可分性&lt;/h3&gt;

&lt;p&gt;今いる会社では、エンジニアのキャリアパスとして Lead Engineer, Engineering Manager, そして技術スペシャリストとしての Senior Engineer という 3 つのパスが用意されています。Senior はいいとして、Lead と Management って結構不可分では? というのが最近の悩みです。&lt;/p&gt;

&lt;p&gt;特に目標設定やその振り返り、日々の 1 on 1 というのは基本的に Manager としての仕事だと思ってますが、それらを高いレベルでやるには Lead としての能力が重要なのでは、と感じています。自分としては元々 Lead をやっていたわけなので、ピープルマネジメントに比べたらそちらの方がまだ得意だと思えますが、とはいえピープルマネジメントもしながらそういった動き方を求められるのは結構タフじゃない? とも思うわけです。&lt;/p&gt;

&lt;p&gt;これは単に自分の Engineering Manager としての経験値が足りてなかったり、それぞれの役割の違いに対する理解が足りてないからそう思えるのかもしれません。また、チームが成熟して、それぞれの分野においてそれぞれのメンバーがリーダーシップを発揮する範囲が増えていけば、自分が Lead として振る舞う重要性は下がってくるのかもしれません。が、自分の中でまだ明確な方向性が見えていないので、これは先人の意見を是非とも聞いてみたいところです。&lt;/p&gt;

&lt;h3 id=&#34;メンバーとの距離感を近く保つことの重要性&#34;&gt;メンバーとの距離感を近く保つことの重要性&lt;/h3&gt;

&lt;p&gt;僕の Engineering Manager としての前任者は会社の CTO で、CTO との兼任で Engineering Manager をやっていたことになります。僕が SRE チームに異動する前は専任の Engineering Manager の人が別にいましたが、その人が退職した後に Engineering Manager をやりたい人がいなかったので、CTO が兼任であとをつないだ形です。&lt;/p&gt;

&lt;p&gt;マネジメントの経験で言うと大きな差がある前任者と比べて自分が唯一明らかに勝っているところがあるとすれば、地理的な意味での距離感です。というのも CTO は普段イギリスに住んでいるので、タイムゾーンは 9 時間ずれているし、出張でちょくちょく来ていたとはいえ、僕はそれ以外の時期も含めて常に同じオフィスで働いているわけなので、コミュニケーションに必要なレイテンシはゼロに等しいと言えます。&lt;/p&gt;

&lt;p&gt;距離が近いと他チームの人が自チームのメンバーに対して話しかけていてもなんとなく聞こえてきますし、そこで自分への相談が必要だったらちょっと声を掛けるだけですぐ始められるので、発生した問題に素早くキャッチアップして、解決に動き出せる可能性が高まります。まぁこれは普通に 1 オフィスしかない国内企業で働いていた時は当たり前でしたが。&lt;/p&gt;

&lt;p&gt;以上は地理的な距離感の話ですが、本質的には心理的な距離感を保つことの方がより重要だと思います。その点に関しても、イギリスでスタートアップの Co-Founder/CTO で exit も経験している前任者は属性を切り取るだけで迫力が出ますが、一方自分は曖昧な時間に出社をして、常に座席でお菓子をボリボリ食べたり時々居眠りをしながらボーっと働いている感じの人間なので、迫力もないしツッコミも入れ放題なのではと思います。 (Engineering Manager になってからは必要に応じて普通の時間や普通より早い時間の出社もやっています)&lt;/p&gt;

&lt;p&gt;というのは半分 (?) 冗談ですが、些細な問題でも常に共有してもらえるようにいるには、普段は泰然自若にしてい (るように振る舞っ) たり、コミュニケーションも年齢や立場に関係なくフラットに行うことが重要だと感じています。僕がどんなにボーっとした人間だとしても、世の中には後輩力とでも呼ぶべき能力の高い人たちがいて、社会人歴や社歴だけは長い自分に対してやたら謙遜した態度で接されることも増えてきましたが、そういう人たちに対しても「自分はえらくなんかないんだ、&lt;a href=&#34;http://j-lyric.net/artist/a05efec/l048beb.html&#34;&gt;ゴミ屑ロンリネス&lt;/a&gt;なんだ」と言い聞かせて、なるべくフラットなコミュニケーションができるよう努めています。&lt;/p&gt;

&lt;p&gt;よりアクティブな振る舞い方でいえば、「自分はあなたの味方であり、同じ問題を共有し、その解決のために共闘しているんだ」という態度をいかに演出し、実際に体現するかも重要だと思います。という訳で次のトピックへ。&lt;/p&gt;

&lt;h3 id=&#34;ゴール設定と-それを一緒に追いかけ続けること&#34;&gt;ゴール設定と、それを一緒に追いかけ続けること&lt;/h3&gt;

&lt;p&gt;Engineering Manager になる前、僕は目標設定というものが苦手だったし、むしろ嫌いだった気がします。というのは会社での目標に関してもそうですが、キャリアとか人生といった長いスパンでの目標というのも基本的に持っていません。時間が経てば状況も自分のやりたいことも変わって意味がなさそうだし、何よりめんどくさいので。&lt;/p&gt;

&lt;p&gt;が、今はチーム内で一番目標設定を大事にすべき立場ですし、自分としても少なくともそうありたいと思ってはいるつもりです。&lt;/p&gt;

&lt;p&gt;こうなった要因は、自分が会社の中間管理職として、ある種体制側としてのバイアスがかかっているからというのももちろんあると思います。モヒカンと中指を天高く突き上げ &amp;ldquo;Fuck The System!&amp;rdquo; なんて叫んでいたのも今は昔。 (そんな時代はなかった)&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/np3FXa4ORbY&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;自分が体制側になったからというのもあると思うけど、それだけでもないと思います。マネージャーとしては、他の人にやってもらうことを通じてチームとしてやるべきことを成し遂げていく必要がある訳ですが、そのためにはチームや個々のメンバーを方向付けていく必要がありますし、そのためには一貫したストーリーが必要です。&lt;/p&gt;

&lt;p&gt;目標として実際に決める事柄はなるべく定量的、または達成したかどうかが自明になるように努めていますが、それらはチームや会社の状況が変われば意味を失ったり、より重要な事柄が別に現れたり、ということもままあると思います。そんな中で元の目標にこだわることは会社から見たら意味がないですし、メンバー自身もモチベーションを保ちづらいと思うので、背景のストーリーを大事にして、状況に応じて目標自体を状況に合わせていけるような余白を持てるよう努めています。幸い、今いる会社の制度的には目標設定とそれに対する達成度が給料に反映される訳ではないので、そういった動き方が取りやすい状況にあります。 (OKR みたいなものをイメージしてもらうとわかりやすいと思います)&lt;/p&gt;

&lt;p&gt;もちろん目標は設定するだけではダメで、実際に達成に向けて継続的に努力をしていく必要があります。心理的な距離感に関してのところでも少し書きましたが、Engineering Manager は目標に対して二人三脚で共闘していくものなんだというスタンスは強調しているつもりです。そのために、日頃から 1 on 1 を通じて心理的距離感を近く保ち、メンバーだけでは解決が難しい問題をなるべく早い段階で共有してもらい、実際に解決していくことはとても重要だと感じます。&lt;/p&gt;

&lt;h2 id=&#34;engineering-manager-になってありがたかったこと&#34;&gt;Engineering Manager になってありがたかったこと&lt;/h2&gt;

&lt;p&gt;最後にいい話を少ししてこの記事を締めようと思います。&lt;/p&gt;

&lt;h3 id=&#34;人事や人事制度の存在&#34;&gt;人事や人事制度の存在&lt;/h3&gt;

&lt;p&gt;僕は人事制度なんてなくて済むならその方が良いに違いないと思ってますし、それについては今も変わりません。&lt;/p&gt;

&lt;p&gt;でも現状は、その人事制度に明らかに助けられていますし、そういったものを作り上げてきた人事や以前からのマネージャーたちに一日一万回は感謝しながら仕事しています。もちろん、完璧な制度なんてありえないし、現状の制度に不満が全くない訳ではないけど、全体として良いものだと思っているし、問題点についても積極的にフィードバックしてより良いものにしていく助けになれればと思えるものです。&lt;/p&gt;

&lt;p&gt;特に、今の会社の人事は親会社の制度にアラインしつつも、そこと噛み合わない部分についてはちゃんと現状の組織に合わせたものを作っていく柔軟さも持ち合わせていてすごいなと思わされます。&lt;/p&gt;

&lt;p&gt;目標設定についても基本的には人事が用意した仕組みの中でやっていますし、それへの臨み方についても新人マネージャー向けにちゃんとした研修の機会、それもどっかの訳のわからんコンサル企業への丸投げではなく、最新の研究や書籍などの出典も示された資料を自分たちで作って、自分たちの言葉で話してくれるので、自分もそれに共感できるし、そこから自分の裁量で工夫する余地が与えられている点も素晴らしいなと感じます。&lt;/p&gt;

&lt;p&gt;拙いなりにもこの記事をここまで書けているのも半分くらいは人事のみなさんのおかげです。あとは経費キャッシュレス化だけやっていただけたら当分はなんの文句もありません。&lt;/p&gt;

&lt;h3 id=&#34;チームの内外のメンバーの優秀さ&#34;&gt;チームの内外のメンバーの優秀さ&lt;/h3&gt;

&lt;p&gt;まだ 2 ヶ月しかやってない中ではありますが、やっぱり周囲のメンバーの優秀さには本当に助けられているなと思います。これに関しても一日にもう二万回感謝しています。&lt;/p&gt;

&lt;p&gt;メンバーというのはチーム内のメンバーもそうですが、チーム外の人々もそうです。SRE というのは構造的には他のチームに対して何かしてあげるように見える業務が多いので、感謝されがちで、ともすれば自分たちは偉いんだという勘違いに陥りがちなのかもしれません。&lt;/p&gt;

&lt;p&gt;しかし、こちらも助けられているという感覚が強くあるので、そうならずに済みそうです。例えば新たなツールを導入し、そのためにワークフローを変える必要があっても、こちらが考えてもいなかった方向から意見をくれたり、時にはワークフロー自体をより良いものに変えてくれたりと、むしろこちらが助けられているなと感じます。&lt;/p&gt;

&lt;p&gt;また、チーム内のメンバーについてもみんな自分よりも優秀だと思える人たちばかりで本当に助けられています。僕は無駄に長い社歴で得たアドバンテージを切り崩しながらなんとか Engineering Manager やらせてもらってます。&lt;/p&gt;

&lt;p&gt;とはいえ、今のメンバーのうち何人かは自分も Engineering Manager になる前から採用に関わっていたので、やってきてよかったなと思います。自分が Engineering Manager になるのと同時に 2 人入ってきた二人も爆速で立ち上がってバリューを出し続けているので、これは採用頑張らないといけないなと改めて思わされました。&lt;/p&gt;

&lt;p&gt;メンバーが優秀だとイージーな面と、よりハードなチャレンジを求められる面と両方ありますが、やっぱりより高いチャレンジができる状況の方が幸せに違いないので、自分がバリューを出せる限りにおいては Engineering Manager やっていけたらいいですね。&lt;/p&gt;

&lt;h2 id=&#34;終わりに&#34;&gt;終わりに&lt;/h2&gt;

&lt;p&gt;オンボーディングについて序盤で書くって言っといて忘れていたのでやる気が出たらそのうち書きます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes The Hard Way をやってみた</title>
      <link>https://blog.yuyat.jp/post/kubernetes-the-hard-way/</link>
      <pubDate>Sun, 30 Dec 2018 01:25:45 +0900</pubDate>
      
      <guid>https://blog.yuyat.jp/post/kubernetes-the-hard-way/</guid>
      <description>

&lt;p&gt;冬休みに入ったので、前からやってみたいと思っていた &lt;a href=&#34;https://github.com/kelseyhightower/kubernetes-the-hard-way&#34;&gt;Kubernetes The Hard Way&lt;/a&gt; をやってみました。という日記です。&lt;/p&gt;

&lt;h2 id=&#34;何故やったか&#34;&gt;何故やったか&lt;/h2&gt;

&lt;p&gt;4 月に SRE チームに異動してから 8 ヶ月ほど経ち、その間 Kubernetes クラスタの構築・運用・アプリケーションの移行などあらゆることをして来たが、未だに Kubernetes わかってる感が薄いので、もっと細かいところまで理解しようというモチベーションでやってみた。&lt;/p&gt;

&lt;h2 id=&#34;手順&#34;&gt;手順&lt;/h2&gt;

&lt;p&gt;ほぼ 100% &lt;a href=&#34;https://github.com/kelseyhightower/kubernetes-the-hard-way&#34;&gt;Kubernetes The Hard Way&lt;/a&gt; に書いてある手順通り。GCP を使って、複数のサーバでの作業が必要な時は tmux の &lt;code&gt;set synchronize-panes on&lt;/code&gt; を使って (実は初めて使った)。&lt;/p&gt;

&lt;h2 id=&#34;所要時間&#34;&gt;所要時間&lt;/h2&gt;

&lt;p&gt;合計 3 時間弱。思ったほど時間がかからなかったので、別に普通の土日でも問題なくできる量。所要時間は個人 Slack でスレッド内に進捗や気になった点をメモしながらだったので、それで計測。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Prerequisites ~ Provisioning a CA and Generating TLS Certificates

&lt;ul&gt;
&lt;li&gt;55 分&lt;/li&gt;
&lt;li&gt;Provisioning a CA and Generating TLS Certificates はひたすらいろんな鍵を生成するばかりで退屈だった&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Generating Kubernetes Configuration Files for Authentication ~ Bootstrapping the Kubernetes Control Plane

&lt;ul&gt;
&lt;li&gt;50 分&lt;/li&gt;
&lt;li&gt;Bootstrapping the Kubernetes Control Plane は全体で一番時間がかかったように思う&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Bootstrapping the Kubernetes Worker Nodes ~ Cleaning Up

&lt;ul&gt;
&lt;li&gt;55 分&lt;/li&gt;
&lt;li&gt;実際に Nginx が動いたりするとそこそこ嬉しかった&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なお、個人の GCP アカウントは以前から持っていたので、そこの時間は含まれない。作業に使用する tmux も普段から使っており、そのインストール時間も含まれない。&lt;/p&gt;

&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;思ったほど Hard ではない

&lt;ul&gt;
&lt;li&gt;基本的にはコマンドをコピペするだけで動くので、ミスしなければ誰がやっても普通に動くと思う&lt;/li&gt;
&lt;li&gt;むしろ無意識的にやってもできそうだが、それだとさすがに意味がないので、コマンドだったり設定ファイルの中身はじっくり眺めながら進めた方が良い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;対象者は Kubernetes の運用やその上での開発をある程度やっている人か

&lt;ul&gt;
&lt;li&gt;コピペだけでもできるので、Kubernetes を全く知らない人でもできるとは思うが、さすがにそれで何かを得るのは難しいのではと思った&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;これをやっただけで「これ」と言える何かを得るのは簡単ではないかも

&lt;ul&gt;
&lt;li&gt;全体的なイメージはなんとなく持つことができる&lt;/li&gt;
&lt;li&gt;やってみても、Kubernetes のセットアップ方法は様々なので、どこまでが普遍的な知識なのはわかりづらい&lt;/li&gt;
&lt;li&gt;今回は kube-proxy を systemd で起動したけど、普段仕事で使っているクラスタでは DaemonSet で起動してるはずで、それによって何が違ってくるんだろう、とか&lt;/li&gt;
&lt;li&gt;疑問を元に何かを調べるためのきっかけとしては良いかもしれない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;あらかじめ作業ディレクトリを作って、その中で作業を行うのが良い

&lt;ul&gt;
&lt;li&gt;全て終えた時点で、50 近いファイルが作成される&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CircleCI 上でのコマンドの実行時間を Datadog に残す circle-dd-bench 作った</title>
      <link>https://blog.yuyat.jp/post/circle-dd-bench/</link>
      <pubDate>Tue, 25 Dec 2018 23:30:00 +0900</pubDate>
      
      <guid>https://blog.yuyat.jp/post/circle-dd-bench/</guid>
      <description>

&lt;p&gt;この記事は &lt;a href=&#34;https://qiita.com/advent-calendar/2018/circleci&#34;&gt;CircleCI Advent Calendar 2018&lt;/a&gt; 7 日目の記事です。今日は 12 月 25 日ですが、自分の担当分をサボっていたわけではなく、週末作ったツールについて今朝方ツイートしたところ、CircleCI Japan の中の方に「アドベントカレンダーの7日目が空いてしまったのてすがもしよければ」と誘われて書いている次第です。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;en&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;CircleCI でコマンドごとの実行時間を Datadog に記録するためのコマンドを作った &lt;a href=&#34;https://t.co/TojoKhOQ1f&#34;&gt;https://t.co/TojoKhOQ1f&lt;/a&gt;&lt;/p&gt;&amp;mdash; Yuya Takeyama (@yuya_takeyama) &lt;a href=&#34;https://twitter.com/yuya_takeyama/status/1077375699969728514?ref_src=twsrc%5Etfw&#34;&gt;December 25, 2018&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;というわけで早速この &lt;a href=&#34;https://github.com/yuya-takeyama/circle-dd-bench&#34;&gt;circle-dd-bench&lt;/a&gt; というツールについて紹介します。&lt;/p&gt;

&lt;h2 id=&#34;これは何&#34;&gt;これは何？&lt;/h2&gt;

&lt;p&gt;これは CircleCI 内でコマンドを実行する際、ラッパーとして使用することで、実行時間を Datadog にメトリックとして記録するというものです。&lt;/p&gt;

&lt;p&gt;例えばこのようなコマンドを実行していた場合&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build . -t burzum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように書き換えると使用できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;circle-dd-bench --tag command:docker-build --tag product:burzum -- docker build . -t burzum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際には &lt;code&gt;DATADOG_API_KEY&lt;/code&gt; という環境変数に Datadog の API Key を持たせておく必要があります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--tag&lt;/code&gt; は必須ではなく、デフォルトで CircleCI の以下のような環境変数がタグとして付与されます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CIRCLE_PROJECT_USERNAME&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CIRCLE_PROJECT_REPONAME&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CIRCLE_BRANCH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CIRCLE_JOB&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;使ってみた&#34;&gt;使ってみた&lt;/h2&gt;

&lt;p&gt;実際にこの &lt;code&gt;circle-dd-bench&lt;/code&gt; を使って記録したメトリックを元に Datadog 上で作成したダッシュボードがこちらです。ここではあらゆるサービスの &lt;code&gt;docker build&lt;/code&gt; の実行時間を計測しています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.yuyat.jp/images/circle-dd-bench/datadog.png&#34; width=&#34;1156&#34; height=&#34;322&#34;&gt;&lt;/p&gt;

&lt;p&gt;まだ CircleCI の config に組み込む Pull Request を出して、そのブランチ上で 2-3 回実行しただけで、&lt;code&gt;Dockerfile&lt;/code&gt; の最適化を行なってはいないため、サービスごとの &lt;code&gt;docker build&lt;/code&gt; にかかる時間の変化は誤差のみです。ですが、どのサービスの &lt;code&gt;docker build&lt;/code&gt; に時間がかかっているかは一目瞭然なので、それから最適化に着手していけばいいことになります。&lt;/p&gt;

&lt;h2 id=&#34;モチベーション&#34;&gt;モチベーション&lt;/h2&gt;

&lt;p&gt;一言でいうと、CircleCI の実行時間を最適化するにあたって、各コマンド単位でどれぐらい時間がかかっているのかを定点観測しておきたかったためです。&lt;/p&gt;

&lt;p&gt;私が社員として所属する Quipper ではマイクロサービス化を進めるにあたって、かつては 1 サービス 1 リポジトリだったものを、一つの Monorepo に集約しています。背景については以下の記事やスライドをご覧ください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://quipper.hatenablog.com/entry/future-with-kubernetes&#34;&gt;Kubernetes導入で実現したい世界とその先にあるMicroservices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/yuyatakeyama/how-quipper-works-with-circleci&#34;&gt;How Quipper Works with CircleCI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特にみていただきたいのは後者のスライドに含まれる以下の &lt;a href=&#34;https://speakerdeck.com/yuyatakeyama/how-quipper-works-with-circleci?slide=14&#34;&gt;CircleCI の Workflow のスクリーンショット&lt;/a&gt; です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.yuyat.jp/images/circle-dd-bench/workflow.png&#34; width=&#34;1126&#34; height=&#34;655&#34;&gt;&lt;/p&gt;

&lt;p&gt;たくさんのサービスの Docker Build やユニットテストが並列して実行されるため、このスクリーンショットを作成した時点で 83 もの Job が Workflow 内に含まれます (その後もう少し増えています)&lt;/p&gt;

&lt;p&gt;この図を踏まえてもう少し背景を説明すると、以下のような理由が挙げられます。&lt;/p&gt;

&lt;h3 id=&#34;circleci-の-insights-が-workflow-では役に立たない&#34;&gt;CircleCI の Insights が Workflow では役に立たない&lt;/h3&gt;

&lt;p&gt;CircleCI には Insights という機能があり、Job の実行時間の履歴をグラフとしてビジュアライズする機能があります。&lt;/p&gt;

&lt;p&gt;これは CircleCI 1.0 時代には大変有用でしたが、CircleCI 2.0 の Workflow を使っている場合はそうではありません。質の異なる複数の Job が一様にグラフ化されるため、一見して役に立てるのはこんなんです。&lt;/p&gt;

&lt;p&gt;なので別のアプローチでビジュアライズを試みる必要があります。&lt;/p&gt;

&lt;h3 id=&#34;同じコマンドでも実行時間にばらつきがある&#34;&gt;同じコマンドでも実行時間にばらつきがある&lt;/h3&gt;

&lt;p&gt;ここでは特に &lt;code&gt;docker build&lt;/code&gt; を念頭におきますが、&lt;code&gt;docker build&lt;/code&gt; はキャッシュの有無であったり、キャッシュがあるにしてもどの layer までのキャッシュが使えるかといった場合によって実行時間はまちまちです。最適化の結果ベストケースでの実行時間は速くなっても、キャッシュが効く確率が低く、全体としての実行時間は遅くなる、ということもあるでしょう。&lt;/p&gt;

&lt;p&gt;そういった状況を正しく判断できるようにするには、継続的に実行時間を残しておき、ビジュアライズしておくと Fact Based に判断しやすいでしょう。&lt;/p&gt;

&lt;h3 id=&#34;job-単位での計測ではうまくいかないケースに対応したい&#34;&gt;Job 単位での計測ではうまくいかないケースに対応したい&lt;/h3&gt;

&lt;p&gt;先に掲載した Workflow は、実際は変更を検知したサービスに対してのみユニットテストや &lt;code&gt;docker build&lt;/code&gt; の実行を行なっています。変更がなかった場合は最後のビルドを使いまわしています。&lt;/p&gt;

&lt;p&gt;その場合、&lt;code&gt;docker build&lt;/code&gt; を実行したら数分かかるのに、スキップした場合は数秒で終わったりと、またばらつきが生まれてしまいます。なので、単純に Job 単位での実行時間を記録するのは適切でなくなります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;circle-dd-bench&lt;/code&gt; を使ったアプローチでは、&lt;code&gt;docker build&lt;/code&gt; を実行した時のみ計測・記録が行われるので、そういったばらつきを無視することができます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/yuya-takeyama/circle-dd-bench&#34;&gt;circle-dd-bench&lt;/a&gt; を使うと Fact Based に CircleCI の Workflow を最適化していけるかもしれません。同じような問題を抱えている方は是非使ってみてください。&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/WJBeFy3VcgY&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>CLI ツールを Go で書いて Docker イメージとしてリリースする</title>
      <link>https://blog.yuyat.jp/post/make-tools-in-go-and-release-as-docker-images/</link>
      <pubDate>Wed, 10 Oct 2018 01:30:00 +0900</pubDate>
      
      <guid>https://blog.yuyat.jp/post/make-tools-in-go-and-release-as-docker-images/</guid>
      <description>

&lt;p&gt;最近ようやく開発ツールとして Docker が手に馴染んできたので、タイトルの件も含めていくつか雑多に書きます。&lt;/p&gt;

&lt;h2 id=&#34;cli-ツールを-go-で書いて-docker-イメージとしてリリースする&#34;&gt;CLI ツールを Go で書いて Docker イメージとしてリリースする&lt;/h2&gt;

&lt;p&gt;コマンドラインツールを Go で書く、というのは以前からやっていて、主な理由としては「クロスコンパイルができるのでバイナリリリースが簡単」というのがありました。便利なので、クロスコンパイルから GitHub へのリリースを一発でやってくれるラッパーツールを書いたこともありました (一応動くものの、開発は非常に中途半端なところで止まってますが)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/yuya_takeyama/items/ac200058f9a27a5db12f&#34;&gt;gox して ghr するツール ggallin 作った&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;その後、2017 年に入って Docker で Multi-Stage Builds という機能が実装されてからは、&lt;code&gt;Dockerfile&lt;/code&gt; 内の build ステージで &lt;code&gt;go build&lt;/code&gt; したバイナリを最終的なステージから &lt;code&gt;COPY --from=build&lt;/code&gt; して使う、ということもやってきました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/develop/develop-images/multistage-build/&#34;&gt;Use multi-stage builds&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この &lt;code&gt;COPY --from&lt;/code&gt; ですが、ドキュメントをよく見ると &lt;code&gt;COPY --from=nginx:latest&lt;/code&gt; などとすることで、外部のイメージも stage として利用することができると書いてあります。&lt;/p&gt;

&lt;p&gt;これを利用すると、&lt;code&gt;Dockerfile&lt;/code&gt; 内で必要なツールはこんな感じにインストールすることができるようになります。 (例は前の記事で紹介している &lt;a href=&#34;https://blog.yuyat.jp/post/guruguru-cache/&#34;&gt;guruguru-cache&lt;/a&gt; をインストールするもの)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;COPY --from=yuyat/guruguru-cache /usr/local/bin/guruguru-cache /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;guruguru-cache は Go で書かれていてシングルバイナリとしてビルドされているので、このように &lt;code&gt;$PATH&lt;/code&gt; の通ったところに &lt;code&gt;COPY&lt;/code&gt; してくるだけで使えるようになります。&lt;/p&gt;

&lt;p&gt;ただし、動的リンクされている場合は動かないことがあるので、静的リンクにする必要があります。以下の記事を参考にしています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.wrouesnel.com/articles/Totally%20static%20Go%20builds/&#34;&gt;Totally static Go builds&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以前に &lt;a href=&#34;https://github.com/yuya-takeyama/circle-gh-tee&#34;&gt;Rust で書いたツール&lt;/a&gt; も同じやり方で手元で使ってたりするんですが、この時はその辺に気を使っていたわけではないので、たまたま動いているだけかもしれません。 (ビルドと実行が同じベースイメージで行われていれば普通に動くことも多い)&lt;/p&gt;

&lt;p&gt;最近 Webpacker 用の &lt;code&gt;Dockerfile&lt;/code&gt; で、ruby のイメージの中から &lt;code&gt;COPY --from=node&lt;/code&gt; で &lt;code&gt;node&lt;/code&gt; のバイナリを直接引っ張ってきているのをちょいちょい見ますが、Quipper で一番 Docker に詳しい &lt;a href=&#34;http://twitter.com/mtsmfm&#34;&gt;@mtsmfm&lt;/a&gt; さんに聞いたところ、「多分 ruby と node のベースイメージが近いからたまたま動いているだけで、手元で使うのはいいけど本番ではやるべきではないですね」とのような意見をもらって、「なるほど、確かに〜」と思ったのでした。 (確かにどちらも &lt;code&gt;buildpack-deps:stretch&lt;/code&gt; がベース。バージョンによっても違うかもですが)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/docker-library/ruby/blob/ccacdf5eb9e69b6f249a890c87621679410e7d74/2.5/stretch/Dockerfile&#34;&gt;ruby&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/nodejs/docker-node/blob/11d4e7fb83a52801e177a08c12eeacaf41498a54/10/stretch/Dockerfile&#34;&gt;node&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;あと言うまでもないとは思いますが、これはあくまでも &lt;code&gt;docker build&lt;/code&gt; 内で実行する開発ツール的なやつに有効なテクニックで、サーバやミドルウェアは素直で別コンテナで動かしてネットワークを通じてやり取りするのが良いでしょう (Apache と MySQL の両方を動かすようなイメージを作るべきではない)&lt;/p&gt;

&lt;h2 id=&#34;docker-hub-よりも-docker-cloud&#34;&gt;Docker Hub よりも Docker Cloud&lt;/h2&gt;

&lt;p&gt;というわけで最近は前よりも Docker イメージを作ることが増えて、ちょっと前までは Docker Hub を使っていました。&lt;/p&gt;

&lt;p&gt;でもビルドの進捗がよくわからんなー、と思って社内の Slack で文句を言っていたところ、これまた &lt;a href=&#34;http://twitter.com/mtsmfm&#34;&gt;@mtsmfm&lt;/a&gt; さんから「進捗は Docker Cloud の方がわかりやすい」ということだったのでそちらを使い始めました。&lt;/p&gt;

&lt;p&gt;名前はなんとなく知っていたものの、そこで初めて知ったのはどちらも Docker, Inc. が運営するサービスなんですね。しかも内部的にリポジトリのデータは共有されており、&lt;code&gt;docker push&lt;/code&gt; すると両方に同じイメージが表れるという不思議な作り。Docker Hub だと他人の public なイメージも閲覧できるのに対して、Docker Cloud は基本的に自分か所属する組織のイメージ以外は見えないので、Hub としての機能は持ってないようです。&lt;/p&gt;

&lt;p&gt;使ってみると UI 以外にも Automated Build が少しいい感じになっていて、Git の tag は &lt;code&gt;v1.2.3&lt;/code&gt; だったら Docker イメージの tag は &lt;code&gt;1.2.3&lt;/code&gt; というように先頭の v を取る、みたいなことも簡単にできるので便利です。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>docker build 内の bundle install を最適化するために guruguru-cache というツールを作った</title>
      <link>https://blog.yuyat.jp/post/guruguru-cache/</link>
      <pubDate>Tue, 09 Oct 2018 01:10:00 +0900</pubDate>
      
      <guid>https://blog.yuyat.jp/post/guruguru-cache/</guid>
      <description>

&lt;p&gt;作りました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yuya-takeyama/guruguru-cache&#34;&gt;yuya-takeyama/guruguru-cache&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;解決したい問題&#34;&gt;解決したい問題&lt;/h2&gt;

&lt;p&gt;Quipper では開発プラットフォームが Deis (OSS の Heroku クローン) から割と素な感じの Kubernetes へと変わったので、元々は Buildpack で行なっていたコンテナイメージのビルドはシェルスクリプト内で &lt;code&gt;docker build&lt;/code&gt; を直接実行して行うようになりました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://quipper.hatenablog.com/entry/future-with-kubernetes&#34;&gt;Kubernetes導入で実現したい世界とその先にあるMicroservices&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Monorepo なので、Pull Request を出したりマージすると変更のあったサービスの Docker Image のビルドが一気に走るのですが、並列とはいえキューがたまりがちになってきたので、実行時間が気になり始めました。&lt;/p&gt;

&lt;h3 id=&#34;bundle-install-が長い&#34;&gt;&lt;code&gt;bundle install&lt;/code&gt; が長い&lt;/h3&gt;

&lt;p&gt;特に気になるのがこれです。Quipper の場合 Ruby で書かれたアプリが多いので主に Bundler ですが、Node.js の Yarn 等でも同様の問題があります。&lt;/p&gt;

&lt;p&gt;この問題に対するよく知られた対処として、「&lt;code&gt;Gemfile&lt;/code&gt;/&lt;code&gt;Gemfile.lock&lt;/code&gt; を先に &lt;code&gt;ADD&lt;/code&gt;/&lt;code&gt;COPY&lt;/code&gt; して &lt;code&gt;bundle install&lt;/code&gt; を実行したあとでアプリ全体を &lt;code&gt;ADD&lt;/code&gt;/&lt;code&gt;COPY&lt;/code&gt; する」というものがあります。
(以前は Ruby のオフィシャルイメージの中の &lt;code&gt;onbuild&lt;/code&gt; タグがついたものが同じようなことをしてくれましたが&lt;a href=&#34;https://github.com/docker-library/official-images/issues/2076&#34;&gt;いつの間にか deprecate されていた&lt;/a&gt;ようです)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/kaiinui/items/5ec52437d114e364b7f0&#34;&gt;Docker で bundle install を爆速にする&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;こうすることで、&lt;code&gt;Gemfile&lt;/code&gt;/&lt;code&gt;Gemfile.lock&lt;/code&gt; 以外のファイルに更新が起こった時点で Docker のレイヤーキャッシュが無効になり、&lt;code&gt;bundle install&lt;/code&gt; がゼロからになってしまう問題を避けられます。&lt;/p&gt;

&lt;p&gt;ですが、この場合も結局 &lt;code&gt;Gemfile&lt;/code&gt; に 1 gem 追加しただけでも &lt;code&gt;bundle install&lt;/code&gt; は最初から実行されて、特に &lt;code&gt;nokogiri&lt;/code&gt; のようなネイティブ拡張を含む gem のビルドに時間を取られてしまうことには変わりありません。&lt;/p&gt;

&lt;p&gt;これかを解決するには、&lt;code&gt;docker build&lt;/code&gt; 時に &lt;code&gt;bundle install&lt;/code&gt; したディレクトリ全体をキャッシュとして保持しておき、次回以降のビルドに引き継ぐ必要があります。&lt;/p&gt;

&lt;h2 id=&#34;guruguru-cache&#34;&gt;guruguru-cache&lt;/h2&gt;

&lt;p&gt;そこで作ったのが guruguru-cache です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yuya-takeyama/guruguru-cache&#34;&gt;yuya-takeyama/guruguru-cache&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://circleci.com/docs/2.0/caching/&#34;&gt;CircleCI 2.0 のキャッシュシステム&lt;/a&gt;がシンプルで好きだったので、これと似たようなことがコマンドでできれば良いなと思って作りました。&lt;strong&gt;Circle&lt;/strong&gt; CI 由来なのでぐるぐるです。&lt;a href=&#34;https://www.youtube.com/watch?v=Ypx_A6No600&#34;&gt;乃木坂46のデビューシングル&lt;/a&gt;や&lt;a href=&#34;https://en.wikipedia.org/wiki/Guru_Guru&#34;&gt;ジャーマンロックバンド&lt;/a&gt;は関係ありません。&lt;/p&gt;

&lt;h3 id=&#34;必要なもの&#34;&gt;必要なもの&lt;/h3&gt;

&lt;p&gt;キャッシュファイルは S3 に保存するため、S3 バケットと、そバケットにアクセスできる IAM User 及びアクセスキーが必要です。現状は環境変数でしか渡せないので、以下の値を用意する必要があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AWS_ACCESS_KEY_ID&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AWS_SECRET_ACCESS_KEY&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AWS_REGION&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また、必須ではありませんが、&lt;a href=&#34;https://docs.aws.amazon.com/AmazonS3/latest/dev/lifecycle-expire-general-considerations.html&#34;&gt;Object Expiration&lt;/a&gt; の設定をしておくと良いでしょう。&lt;/p&gt;

&lt;h3 id=&#34;インストール&#34;&gt;インストール&lt;/h3&gt;

&lt;p&gt;現状リリース済みのバイナリは用意していないので、&lt;code&gt;go get&lt;/code&gt; で自前ビルドするか、&lt;code&gt;docker build&lt;/code&gt; 用であれば latest の Docker イメージからコピーしてくるのが簡単です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;# In Dockerfile
COPY --from=yuyat/guruguru-cache /usr/local/bin/guruguru-cache /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;キャッシュの保存&#34;&gt;キャッシュの保存&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ guruguru-cache store [flags] [cache key] [paths...]

Flags:
  -h, --help               help for store
      --s3-bucket string   S3 bucket to upload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一引数にキャッシュキーを指定し、第二引数以降にはキャッシュ対象のパスを複数指定できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ guruguru-cache store --s3-bucket=example-cache \
  &#39;gem-v1-{{ arch }}-{{ checksum &amp;quot;Gemfile.lock&amp;quot; }}&#39; \
  vendor/bundle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;キャッシュキーには CircleCI と同様のテンプレート記法が使えます。テンプレート記法についてはあとで別途説明します。&lt;/p&gt;

&lt;h3 id=&#34;キャッシュの復元&#34;&gt;キャッシュの復元&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ guruguru-cache restore [flags] [cache keys...]

Flags:
  -h, --help               help for restore
      --s3-bucket string   S3 bucket to upload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;キャッシュキーを複数指定することができます。順番にキャッシュを前方一致で探索し、見つかるまで次のキーにフォールバックしていきます。キャッシュが見つからなければ何もせず終了します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ guruguru-cache restore --s3-bucket=example-cache \
  &#39;gem-v1-{{ arch }}-{{ checksum &amp;quot;Gemfile.lock&amp;quot; }}&#39; \
  &#39;gem-v1-{{ arch }}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この例ではまず &lt;code&gt;Gemfile.lock&lt;/code&gt; のチェックサムが一致するキャッシュを探索します。これが見つかった場合、通常は gem が過不足なくキャッシュから復元されるので、&lt;code&gt;bundle install&lt;/code&gt; は一瞬で終わるはずです。 (もちろん実装依存ですが)&lt;/p&gt;

&lt;p&gt;チェックサムが一致するキャッシュが見つからなかった場合、2 番目の &lt;code&gt;gem-v1-{{ arch }}&lt;/code&gt; にフォールバックします。複数見つかった場合は作成日時が一番新しいものを取得します。この辺は CircleCI と同様の挙動にしたつもりです。&lt;/p&gt;

&lt;h3 id=&#34;キャッシュキーのテンプレート&#34;&gt;キャッシュキーのテンプレート&lt;/h3&gt;

&lt;p&gt;キャッシュキーには以下のテンプレート記法が使えます。まんま CircleCI です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{{ checksum &amp;quot;FILEPATH&amp;quot; }}&lt;/code&gt;: ファイルの MD5 チェックサム&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{ arch }}&lt;/code&gt;: CPU アーキテクチャ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{ epoch }}&lt;/code&gt;: UNIX タイムスタンプ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{ .Environment.FOO }}&lt;/code&gt;: 環境変数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;{{ .Branch }}&lt;/code&gt; や &lt;code&gt;{{ .Revision }}&lt;/code&gt; のような CircleCI 固有の環境変数に依存したものはありません。CI 基盤で適宜取得して &lt;code&gt;docker build&lt;/code&gt; 時に &lt;code&gt;--build-arg&lt;/code&gt; として渡す、等する必要があります。&lt;/p&gt;

&lt;h2 id=&#34;デモ&#34;&gt;デモ&lt;/h2&gt;

&lt;p&gt;CircleCI 内で &lt;code&gt;docker build&lt;/code&gt; を行う例を以下に用意してみました。ファイルとして見るべきものは以下の 2 つです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yuya-takeyama/guruguru-cache-circleci-example/blob/master/Dockerfile&#34;&gt;Dockerfile&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;キャッシュの復元 -&amp;gt; &lt;code&gt;bundle install&lt;/code&gt; -&amp;gt; キャッシュの保存となっていることがわかると思います&lt;/li&gt;
&lt;li&gt;CircleCI のジョブ本体のコンテナと Remote Docker とでキャッシュを共有できたら良いかなと思いましたが、実行してみたときは CPU アーキテクチャの微妙な違いによってうまく共有できませんでした&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://circleci.com/gh/yuya-takeyama/guruguru-cache-circleci-example/4&#34;&gt;https://circleci.com/gh/yuya-takeyama/guruguru-cache-circleci-example/4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;現実のケースではテストの実行用と本番環境での実行用とでは必要な gem が微妙に異なると思うので、キャッシュを共有できてもそんなに嬉しくない気もします&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yuya-takeyama/guruguru-cache-circleci-example/blob/master/.circleci/config.yml&#34;&gt;.circleci/config.yml&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;guruguru-cache&lt;/code&gt; の実行に必要な環境変数を &lt;code&gt;--build-arg&lt;/code&gt; として渡しています&lt;/li&gt;
&lt;li&gt;CircleCI のジョブ本体のコンテナと Remote Docker とでキャッシュを共有できたら良いかなと思いましたが、実行してみたときは CPU アーキテクチャの微妙な違いによってうまく共有できませんでした&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://circleci.com/gh/yuya-takeyama/guruguru-cache-circleci-example/4&#34;&gt;https://circleci.com/gh/yuya-takeyama/guruguru-cache-circleci-example/4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;現実のケースではテストの実行用と本番環境での実行用とでは必要な gem が微妙に異なると思うので、キャッシュを共有できてもそんなに嬉しくない気もします&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ビルド時間の計測&#34;&gt;ビルド時間の計測&lt;/h3&gt;

&lt;p&gt;はじめに、初回のキャッシュなしの状態です。キャッシュを復元・保存するロジックは既に入っていますが、初回なので当然キャッシュがない状態です。コードはほぼ &lt;code&gt;rails new&lt;/code&gt; した直後のものです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://circleci.com/gh/yuya-takeyama/guruguru-cache-circleci-example/4&#34;&gt;https://circleci.com/gh/yuya-takeyama/guruguru-cache-circleci-example/4&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker build&lt;/code&gt;: 02:01&lt;/li&gt;
&lt;li&gt;&lt;code&gt;guruguru-cache restore&lt;/code&gt;: 約 1 秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;guruguru-cache store&lt;/code&gt;: 約 10 秒&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次に、ネイティブ拡張を含む&lt;a href=&#34;https://github.com/yuya-takeyama/guruguru-cache-circleci-example/commit/bf53270f59062927496ded5f8304d76c34b8d4bc&#34;&gt;いくつかの gem を追加&lt;/a&gt;した状態で計測してみます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://circleci.com/gh/yuya-takeyama/guruguru-cache-circleci-example/5&#34;&gt;https://circleci.com/gh/yuya-takeyama/guruguru-cache-circleci-example/5&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker build&lt;/code&gt;: 01:34&lt;/li&gt;
&lt;li&gt;&lt;code&gt;guruguru-cache restore&lt;/code&gt;: 約 15 秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;guruguru-cache store&lt;/code&gt;: 約 20 秒&lt;/li&gt;
&lt;li&gt;ほとんどの gem はキャッシュから復元されるので、差分だけのインストールが行われていることがわかります&lt;/li&gt;
&lt;li&gt;&lt;code&gt;libv8&lt;/code&gt; や &lt;code&gt;mini_racer&lt;/code&gt; 等の、ビルドが必要な gem がいくつか含まれていても、全体としては速くなっていることがわかります&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そして、同じ gem を追加した状態だが、&lt;code&gt;guruguru-cache&lt;/code&gt; を一切使わないものです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://circleci.com/gh/yuya-takeyama/guruguru-cache-circleci-example/6&#34;&gt;https://circleci.com/gh/yuya-takeyama/guruguru-cache-circleci-example/6&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker build&lt;/code&gt;: 02:12&lt;/li&gt;
&lt;li&gt;&lt;code&gt;guruguru-cache&lt;/code&gt; にかかる時間はなし&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というわけで、これを見る限りでは &lt;code&gt;guruguru-cache&lt;/code&gt; を使うメリットはあると言えそうです。&lt;/p&gt;

&lt;p&gt;実際は &lt;code&gt;nokogiri&lt;/code&gt; のようなビルドに時間のかかる gem がどれだけ含まれるのかにも寄るし、レイヤーキャッシュによる &lt;code&gt;bundle install&lt;/code&gt; 自体のインストールがどれだけスキップされる場合だったり、レイヤーキャッシュはないが &lt;code&gt;guruguru-cache&lt;/code&gt; のキャッシュはそのまま存在してキャッシュの保存はスキップされるケースなど、色々パターンがあるので、もう少し長い目で計測・観察が必要そうです。&lt;/p&gt;

&lt;h2 id=&#34;今後改善したいポイント&#34;&gt;今後改善したいポイント&lt;/h2&gt;

&lt;h3 id=&#34;キャッシュのネームスペース&#34;&gt;キャッシュのネームスペース&lt;/h3&gt;

&lt;p&gt;単一のバケットに複数リポジトリのキャッシュを格納できるよう、ネームスペースの指定ができてはどうかと思っています。S3 上はパスの prefix になるだけなので、キャッシュキー自体に含めてもいいかもしれませんが、この後の設定ファイルも込みでやると便利かもしれません。&lt;/p&gt;

&lt;h3 id=&#34;設定ファイルへの対応&#34;&gt;設定ファイルへの対応&lt;/h3&gt;

&lt;p&gt;CircleCI のキャッシュでは、ビルドの設定ファイルのあちこちにキャッシュキーが散らばるので、一斉にキーを変更する必要があるときに煩雑になってしまう問題があると感じています。&lt;/p&gt;

&lt;p&gt;なので、&lt;code&gt;guruguru-cache&lt;/code&gt; 用の設定ファイル内にキーの情報をプリセットとして持たせておいて、コマンドからはそのプリセットを指定するだけにできると良いのではないかと考えています。イメージ的には以下のような感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;# 設定ファイル
s3-bucket: example-cache
namespace: my-blog-app
presets:
  gem:
    store:
      key: gem-v1-{{ arch }}-{{ checksum &amp;quot;Gemfile.lock&amp;quot; }}
      paths:
        - vendor/bundle
    restore:
      keys:
        - gem-v1-{{ arch }}-{{ checksum &amp;quot;Gemfile.lock&amp;quot; }}
        - gem-v1-{{ arch }}
  npm:
    store:
      key: npm-v1-{{ arch }}-{{ checksum &amp;quot;yarn.lock&amp;quot; }}
      paths:
        - node_modules
    restore:
      keys:
        - npm-v1-{{ arch }}-{{ checksum &amp;quot;yarn.lock&amp;quot; }}
        - npm-v1-{{ arch }}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;# Dockerfile
RUN guruguru-cache restore --preset gem
RUN bundle install --path=vendor/bundle
RUN guruguru-cache store --preset gem

RUN guruguru-cache restore --preset npm
RUN yarn install
RUN guruguru-cache store --preset npm
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;アップロード-ダウンロードの高速化&#34;&gt;アップロード・ダウンロードの高速化&lt;/h3&gt;

&lt;p&gt;全然検証してませんが、RANGE リクエストを並列化させれば高速化できるんじゃないかと思っています。&lt;/p&gt;

&lt;h3 id=&#34;ファイル属性の維持&#34;&gt;ファイル属性の維持&lt;/h3&gt;

&lt;p&gt;キャッシュ展開時のファイル属性 (更新日時とか) は今のところ適当ですが、ちゃんと保持した方が良いケースが多いと思うのでちゃんとしたいです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes の ConfigMap を Immutable に管理する</title>
      <link>https://blog.yuyat.jp/post/kubernetes-immutable-configmap/</link>
      <pubDate>Sun, 01 Jul 2018 21:00:00 +0900</pubDate>
      
      <guid>https://blog.yuyat.jp/post/kubernetes-immutable-configmap/</guid>
      <description>

&lt;p&gt;Quipper では Microservices 基盤として Kubernetes によるクラスタを構築し、もうすぐ本番環境にリリースしようとしています。本当は &lt;a href=&#34;https://deis.com/docs/workflow/&#34;&gt;Deis Workflow&lt;/a&gt; で使う Kubernetes クラスタを既に本番で運用していますが、Deis なしでの運用に変えようとしているのが最近の状況です。&lt;/p&gt;

&lt;p&gt;そこら辺の背景は 2018/07/19 に行われる &lt;a href=&#34;https://techplay.jp/event/680406&#34;&gt;Quipper Product Meetup&lt;/a&gt; でお話しするとして、今は YAML の管理どうするかみたいなところから試行錯誤している状態で、基本的には Pull Request ベースでレビューしてマージされたらデプロイ、みたいなことをアプリでもクラスタでもやる感じになっています。&lt;/p&gt;

&lt;p&gt;今日は、その中でも &lt;code&gt;ConfigMap&lt;/code&gt; をどう扱うか、について Mutable/Immutable 2 つのアプローチについて実際に動く設定・スクリプト付きで紹介します。&lt;/p&gt;

&lt;p&gt;設定・スクリプトは全て GitHub のリポジトリに置いています: &lt;a href=&#34;https://github.com/yuya-takeyama/kubernetes-immutable-configmap-example&#34;&gt;yuya-takeyama/kubernetes-immutable-configmap-example&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;Kubernetes における &lt;code&gt;ConfigMap&lt;/code&gt; は設定値や設定ファイルを保持するためのリソースで、&lt;code&gt;Deployment&lt;/code&gt; (&lt;code&gt;Pod&lt;/code&gt;) からは環境変数として読み込んだり、ファイルとして Volume にマウントしたりして使用します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ConfigMap&lt;/code&gt; を更新するだけでは、それを参照する &lt;code&gt;Deployment&lt;/code&gt; (&lt;code&gt;Pod&lt;/code&gt;) はロールアウトされず、環境変数等にも反映されません。ロールアウトするために何か工夫が必要です。&lt;/p&gt;

&lt;h2 id=&#34;元ネタ&#34;&gt;元ネタ&lt;/h2&gt;

&lt;p&gt;「&lt;code&gt;ConfigMap&lt;/code&gt; を immutable にせよ」というのは GitHub/Stack Overflow はじめ様々なところで言及されています。&lt;/p&gt;

&lt;p&gt;ですが、実際に動く例というものがなさそうなので、そういった言及を元に想像で作ってみたのが今回の例です。&lt;/p&gt;

&lt;p&gt;実際に参考にしたのは以下のコメントです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/pull/31701#issuecomment-252110430&#34;&gt;https://github.com/kubernetes/kubernetes/pull/31701#issuecomment-252110430&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Kubernetes/GKE/CNCF のメンバーである &lt;a href=&#34;https://github.com/bgrant0607&#34;&gt;Brian Grant&lt;/a&gt; によるコメント&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mutable-なアプローチ&#34;&gt;Mutable なアプローチ&lt;/h2&gt;

&lt;p&gt;まずはより素朴なアプローチとして Mutable なアプローチです。大まかには以下のような仕組みです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;環境変数を保持する &lt;code&gt;ConfigMap&lt;/code&gt; は常に同一のものを更新する&lt;/li&gt;
&lt;li&gt;それを参照する &lt;code&gt;Pod&lt;/code&gt; には &lt;code&gt;annotations&lt;/code&gt; として &lt;code&gt;ConfigMap&lt;/code&gt; ファイルのチェックサムを保持する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConfigMap&lt;/code&gt; に変更があると &lt;code&gt;Pod&lt;/code&gt; が持つチェックサムも変更されるので、&lt;code&gt;kubectl apply&lt;/code&gt; 時にロールアウトが実行される&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;deployment&#34;&gt;Deployment&lt;/h3&gt;

&lt;p&gt;注目すべきは以下の 2 点です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;環境変数は &lt;code&gt;envFrom&lt;/code&gt; を使って &lt;code&gt;nginx-config&lt;/code&gt; という &lt;code&gt;ConfigMap&lt;/code&gt; を参照している&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pod&lt;/code&gt; の &lt;code&gt;annotations&lt;/code&gt; にはチェックサムを保持するためのプレースホルダ &lt;code&gt;&amp;quot;${config_checksum}&amp;quot;&lt;/code&gt; を含む

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;envsubst&lt;/code&gt; で埋め込む前提&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: nginx
  namespace: cm-deploy-mutable
spec:
  replicas: 1
  selector:
    matchLabels:
      run: nginx
  template:
    metadata:
      labels:
        run: nginx
      annotations:
        yuyat.jp/configmap.checksum.nginx-config: &amp;quot;${config_checksum}&amp;quot;
    spec:
      containers:
      - envFrom:
        - configMapRef:
            name: nginx-config
        image: nginx:alpine
        name: nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;configmap&#34;&gt;ConfigMap&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ConfigMap&lt;/code&gt; は &lt;code&gt;APP_VERSION=1&lt;/code&gt; という値を保持するだけのプレーンな YAML なのでここでは割愛。&lt;/p&gt;

&lt;h3 id=&#34;デプロイスクリプト&#34;&gt;デプロイスクリプト&lt;/h3&gt;

&lt;p&gt;事前に &lt;code&gt;ConfigMap&lt;/code&gt; ファイルの SHA-1 チェックサムを取っておき、それを &lt;code&gt;envsubst&lt;/code&gt; を使って &lt;code&gt;Deployment&lt;/code&gt; に埋め込んでいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
config_checksum=$(shasum mutable/nginx-config.cm.yaml | awk &#39;{ print $1 }&#39;)

kubectl apply --record -n cm-deploy-mutable \
  -f mutable/cm-deploy-mutable.ns.yaml \
  -f mutable/nginx-config.cm.yaml \
  -f &amp;lt;(cat mutable/nginx.deploy.yaml.tpl | config_checksum=$config_checksum envsubst &#39;$config_checksum&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;デプロイしてみる&#34;&gt;デプロイしてみる&lt;/h3&gt;

&lt;p&gt;初回はそれぞれのリソースが生成されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./mutable/deploy.sh
namespace &amp;quot;cm-deploy-mutable&amp;quot; created
configmap &amp;quot;nginx-config&amp;quot; created
deployment &amp;quot;nginx&amp;quot; created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この状態で環境変数 &lt;code&gt;APP_VERSION&lt;/code&gt; には &lt;code&gt;1&lt;/code&gt; がセットされています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./mutable/version.sh
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何も変更せずに再度デプロイしても、何も起こりません。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./mutable/deploy.sh
namespace &amp;quot;cm-deploy-mutable&amp;quot; configured
configmap &amp;quot;nginx-config&amp;quot; unchanged
deployment &amp;quot;nginx&amp;quot; unchanged
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;APP_VERSION&lt;/code&gt; を &lt;code&gt;2&lt;/code&gt; に変更してデプロイすると、ロールアウトが行われます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./mutable/deploy.sh
namespace &amp;quot;cm-deploy-mutable&amp;quot; configured
configmap &amp;quot;nginx-config&amp;quot; configured
deployment &amp;quot;nginx&amp;quot; configured
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナ内の環境変数も正常に変更されました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./mutable/version.sh
2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mutable-なアプローチの問題点&#34;&gt;Mutable なアプローチの問題点&lt;/h3&gt;

&lt;p&gt;ここまでは上手くいっていますが、問題となるのはロールバックする時です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl rollout undo deploy/nginx -n cm-deploy-mutable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この状態で環境変数を確認すると、&lt;code&gt;2&lt;/code&gt; のままで、元に戻っていないことがわかります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./mutable/version.sh
2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ロールバックされるのはあくまでも &lt;code&gt;Deployment&lt;/code&gt; なので、それにひもづく &lt;code&gt;ConfigMap&lt;/code&gt; が変わらない以上は当然の結果です。&lt;/p&gt;

&lt;p&gt;ですが、環境変数等の設定値も含めてロールバックしたい場合には困りますね。&lt;/p&gt;

&lt;h2 id=&#34;immutable-なアプローチ&#34;&gt;Immutable なアプローチ&lt;/h2&gt;

&lt;p&gt;Mutable なアプローチの問題点を解決するための Immutable なアプローチは以下のようなものです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;環境変数を保持する &lt;code&gt;ConfigMap&lt;/code&gt; の name には suffix としてチェックサムを不可する

&lt;ul&gt;
&lt;li&gt;内容が変わると新しいチェックサムを持った &lt;code&gt;ConfigMap&lt;/code&gt; を毎回新しく作成する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pod&lt;/code&gt; からもそのチェックサム付きの名前で参照する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConfigMap&lt;/code&gt; に変更があると &lt;code&gt;Pod&lt;/code&gt; 参照する &lt;code&gt;ConfigMap&lt;/code&gt; が毎回変わるので、&lt;code&gt;kubectl apply&lt;/code&gt; 時にロールアウトが実行される&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;deployment-1&#34;&gt;Deployment&lt;/h3&gt;

&lt;p&gt;Mutable なものとだいたい似ていますが、差分は以下の 2 点です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;チェックサムを保持する &lt;code&gt;annotations&lt;/code&gt; を削除

&lt;ul&gt;
&lt;li&gt;これは敢えて持たせたままにするのもありだと思います&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;envFrom&lt;/code&gt; で参照する &lt;code&gt;ConfigMap&lt;/code&gt; の名前の suffix 部分がプレースホルダになっている

&lt;ul&gt;
&lt;li&gt;やはり &lt;code&gt;envsubst&lt;/code&gt; で値を埋め込む前提&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: nginx
  namespace: cm-deploy-immutable
spec:
  replicas: 1
  selector:
    matchLabels:
      run: nginx
  template:
    metadata:
      labels:
        run: nginx
    spec:
      containers:
      - envFrom:
        - configMapRef:
            name: &amp;quot;nginx-config-${config_checksum}&amp;quot;
        image: nginx:alpine
        name: nginx

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;configmap-1&#34;&gt;ConfigMap&lt;/h3&gt;

&lt;p&gt;Mutable なアプローチではプレーンな YAML でしたが、こちらでは &lt;code&gt;ConfigMap&lt;/code&gt; も &lt;code&gt;envsubst&lt;/code&gt; による値の埋め込みを行います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
data:
  APP_VERSION: &amp;quot;1&amp;quot;
kind: ConfigMap
metadata:
  name: nginx-config-${config_checksum}
  namespace: cm-deploy-immutable
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;デプロイスクリプト-1&#34;&gt;デプロイスクリプト&lt;/h3&gt;

&lt;p&gt;事前に &lt;code&gt;ConfigMap&lt;/code&gt; ファイル (テンプレート) のチェックサムを取るのは同じですが、&lt;code&gt;Deployment&lt;/code&gt; だけでなく &lt;code&gt;ConfigMap&lt;/code&gt; にも &lt;code&gt;envsubst&lt;/code&gt; での値の埋め込みを行います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
config_checksum=$(shasum immutable/nginx-config.cm.yaml.tpl | awk &#39;{ print $1 }&#39;)

kubectl apply --record -n cm-deploy-immutable \
  -f immutable/cm-deploy-immutable.ns.yaml \
  -f &amp;lt;(cat immutable/nginx-config.cm.yaml.tpl | config_checksum=$config_checksum envsubst &#39;$config_checksum&#39;) \
  -f &amp;lt;(cat immutable/nginx.deploy.yaml.tpl | config_checksum=$config_checksum envsubst &#39;$config_checksum&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;デプロイしてみる-1&#34;&gt;デプロイしてみる&lt;/h3&gt;

&lt;p&gt;初回はやはりそれぞれのリソースが生成されます。&lt;code&gt;ConfigMap&lt;/code&gt; の名前にチェックサムが含まれることがわかります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./immutable/deploy.sh
namespace &amp;quot;cm-deploy-immutable&amp;quot; created
configmap &amp;quot;nginx-config-12db160438b100c95eb77c821899f524d6027405&amp;quot; created
deployment &amp;quot;nginx&amp;quot; created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;環境変数は当然ちゃんとセットされています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./immutable/version.sh
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ConfigMap&lt;/code&gt; に変更がない状態で再度適用しても、何も変更が起こらないのは Mutable なときと同じです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./immutable/deploy.sh
namespace &amp;quot;cm-deploy-immutable&amp;quot; configured
configmap &amp;quot;nginx-config-12db160438b100c95eb77c821899f524d6027405&amp;quot; unchanged
deployment &amp;quot;nginx&amp;quot; unchanged
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで &lt;code&gt;APP_VERSION&lt;/code&gt; を &lt;code&gt;2&lt;/code&gt; に変更してデプロイすると、今度はロールアウトが行われます。&lt;code&gt;ConfigMap&lt;/code&gt; は新しく作られていることがわかります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./immutable/deploy.sh
namespace &amp;quot;cm-deploy-immutable&amp;quot; configured
configmap &amp;quot;nginx-config-b6fe7e2f2edca16c3778836541a399245ca2372e&amp;quot; created
deployment &amp;quot;nginx&amp;quot; configured
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンテナ内の環境変数も正常に変更されました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./immutable/version.sh
2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ロールバックしてみる&#34;&gt;ロールバックしてみる&lt;/h3&gt;

&lt;p&gt;Mutable なアプローチで問題になったロールバックをこちらでもやってみます。そちらではロールバックしたにもかかわらず、&lt;code&gt;APP_VERSION&lt;/code&gt; は &lt;code&gt;2&lt;/code&gt; のままで元に戻ってくれませんでした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl rollout undo deploy/nginx -n cm-deploy-immutable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでコンテナ内の環境変数を確認すると、見事 &lt;code&gt;1&lt;/code&gt; に戻っています！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./immutable/version.sh
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ロールバックすることで &lt;code&gt;Pod&lt;/code&gt; が参照する &lt;code&gt;ConfigMap&lt;/code&gt; が一つ前のものに書き換わり、その &lt;code&gt;ConfigMap&lt;/code&gt; には作成時のままの値が入っているので、今度は &lt;code&gt;ConfigMap&lt;/code&gt; ごとロールバックされました。&lt;/p&gt;

&lt;p&gt;今回は &lt;code&gt;ConfigMap&lt;/code&gt; のみの変更でしたが、&lt;code&gt;Deployment&lt;/code&gt; に同時に変更を加えていた場合、その変更もアトミックになるのでロールバックも同様にアトミックに行われることになります。&lt;/p&gt;

&lt;h3 id=&#34;immutable-なアプローチの問題点&#34;&gt;Immutable なアプローチの問題点&lt;/h3&gt;

&lt;p&gt;Mutable なアプローチで問題になったロールバックも上手く行きましたが、こちらは &lt;code&gt;ConfigMap&lt;/code&gt; に変更があるごとに毎回新しく &lt;code&gt;ConfigMap&lt;/code&gt; が作られてしまいます。&lt;/p&gt;

&lt;p&gt;気にせず放置、というのも一つのやり方だと思いますが、気になるのであれば以下のような手順で対処することが考えられます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConfigMap&lt;/code&gt; には &lt;code&gt;label&lt;/code&gt; で共通の値 (&lt;code&gt;nginx-config&lt;/code&gt; 等) を持たせておく&lt;/li&gt;
&lt;li&gt;&lt;code&gt;label&lt;/code&gt; に紐付く &lt;code&gt;ConfigMap&lt;/code&gt; を全て取得し、&lt;code&gt;metadata&lt;/code&gt; が持つ &lt;code&gt;creationTimestamp&lt;/code&gt; でソートし、新しいものいくつかを残して残りは全て削除する

&lt;ul&gt;
&lt;li&gt;ということを &lt;code&gt;CronJob&lt;/code&gt; とかでやると良いのかも&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Pod&lt;/code&gt; にとっての &lt;code&gt;ReplicaSet&lt;/code&gt; のようなものが &lt;code&gt;ConfigMap&lt;/code&gt; にも欲しいですね。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes-sigs/kustomize&#34;&gt;kustomize&lt;/a&gt; で実現する方法もあるっぽいのでそれはまた今度調べてみます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes-sigs/kustomize/tree/730597b77e0a3a4d4c73668e5b1b414c13c76f5a/examples/helloWorld#how-this-works-with-kustomize&#34;&gt;https://github.com/kubernetes-sigs/kustomize/tree/730597b77e0a3a4d4c73668e5b1b414c13c76f5a/examples/helloWorld#how-this-works-with-kustomize&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なお、Quipper では Kubernetes を使って最高の Microservices 基盤を作りたい SRE を大募集中です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.quipper.com/career/Japan/&#34;&gt;https://www.quipper.com/career/Japan/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Oculus Go で Kindle の電子書籍を寝ながら読む</title>
      <link>https://blog.yuyat.jp/post/oculus-go-kindle/</link>
      <pubDate>Mon, 07 May 2018 04:30:00 +0900</pubDate>
      
      <guid>https://blog.yuyat.jp/post/oculus-go-kindle/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://www.oculus.com/go/&#34;&gt;Oculus Go&lt;/a&gt; を買いました。64GB のものが 29,800 円税込送料なしという圧倒的格安なので、VR に興味のある方は是非買いましょう。Amazon で売られている転売品はくれぐれも買わないように。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.moguravr.com/netflix-oculus-go/&#34;&gt;寝転んでNetflixを大画面で観る方法（Oculus Goユーザー必見）&lt;/a&gt;という記事を読んで、寝ながらの Netflix の体験がとにかく良かったので、Kindle の書籍も同じように読めないかやってみました。&lt;/p&gt;

&lt;h2 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Oculus Go 標準のブラウザで &lt;a href=&#34;https://read.amazon.co.jp/&#34;&gt;Kindle Cloud Reader&lt;/a&gt; を Request desktop mode で開く&lt;/li&gt;
&lt;li&gt;日本語の書籍は基本的に Kindle Cloud Reader 自体の制約で開けない&lt;/li&gt;
&lt;li&gt;漫画は開けるが、読み込みが遅かったり、画面サイズの都合で見開き表示ができなかったりと体験が良くない&lt;/li&gt;
&lt;li&gt;洋書であれば割と普通に読める&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;寝ながら本が読みたい&#34;&gt;寝ながら本が読みたい&lt;/h2&gt;

&lt;p&gt;前から常々寝ながら Kindle 書籍が読みたいと思っていて、去年はそのために iPad 用のアームを買っていました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.yuyat.jp/post/best-buys-2017/&#34;&gt;プログラマが 2017 年に買って良かったもの&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;読むこと自体は寝ながらできるものの、ページをめくる時には手を上に伸ばさないといけないのが煩わしく、リモコンでの操作も難しそうなので、諦めていました。&lt;/p&gt;

&lt;p&gt;が、そこで Oculus Go です。&lt;/p&gt;

&lt;h2 id=&#34;oculus-go-のブラウザで-kindle-cloud-reader-を開く&#34;&gt;Oculus Go のブラウザで Kindle Cloud Reader を開く&lt;/h2&gt;

&lt;p&gt;Kindle Cloud Reader はブラウザで Kindle の電子書籍を読める Web アプリです。&lt;/p&gt;

&lt;p&gt;Oculus Go のブラウザそのままで開くと、非対応ということで Android アプリのダウンロードを促されますが、Oculus Go では Android アプリを動かすことはできません。&lt;/p&gt;

&lt;p&gt;標準ブラウザのブラウジングウィンドウ右上にある Request desktop mode ボタンを有効にした上で &lt;a href=&#34;https://read.amazon.co.jp/&#34;&gt;Kindle Cloud Reader&lt;/a&gt; を開くことで、うまくアクセスできます。&lt;/p&gt;

&lt;p&gt;ただし、キャッシュか何かの都合？でうまく開けないことがあり、そういうときは &lt;code&gt;?foo&lt;/code&gt; といったクエリを URL 末尾に付加すると開けたり開けなかったりします。&lt;/p&gt;

&lt;p&gt;また、ブラウザを開いた状態で寝そべって、コントローラーを上に向けて Oculus ボタンを長押しすれば天井にブラウザを表示することができます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.yuyat.jp/images/oculus-go-kindle/kindle.png&#34; width=&#34;672&#34; height=&#34;670&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;制約&#34;&gt;制約&lt;/h2&gt;

&lt;h3 id=&#34;日本語書籍が読めない&#34;&gt;日本語書籍が読めない&lt;/h3&gt;

&lt;p&gt;日本語の書籍は基本的には読めません。全てが全て読めないというわけではなさそうですが、手元で試した限りは読めるものはありませんでした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mogi2fruits.net/blog/webservice-application/kindle/2826/&#34;&gt;Kindle Cloud Reader でコミック・雑誌以外の”和書”が読めないわけでもない！試してみる価値あり！&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;offline-download-ができない&#34;&gt;Offline download ができない&lt;/h3&gt;

&lt;p&gt;Kindle Cloud Reader にはダウンロードしておくことで、オフラインでも書籍を読める機能があります。ざっと調べた感じ Application Cache API で実装しているようです。&lt;/p&gt;

&lt;p&gt;ですが、Oculus Go 標準のブラウザでは Application Cache API が使えないのか、ダウンロードがうまくいかないようです。&lt;/p&gt;

&lt;p&gt;それで何が問題かというと、漫画を読むときは読み込み時間がかなりかかることになり、ネットワーク環境にもよるかもしれませんが、快適に読むことが難しくなります。&lt;/p&gt;

&lt;h3 id=&#34;見開き表示ができない&#34;&gt;見開き表示ができない&lt;/h3&gt;

&lt;p&gt;これはブラウザの画面サイズの問題だと思うのですが、漫画の見開き表示ができませんでした。Mac のブラウザで試した感じでは画面サイズを十分に広げさえすれば見開き表示になるようです。&lt;/p&gt;

&lt;p&gt;Oculus Go 標準のブラウザでは画面サイズは幅を 3 段階に切り替えられますが、任意のサイズに変更することはできないようです。選択できる最大の幅を選択しても見開き表示にならないので、どうやら難しそうです。&lt;/p&gt;

&lt;h2 id=&#34;結論としてはほぼ洋書専用&#34;&gt;結論としてはほぼ洋書専用&lt;/h2&gt;

&lt;p&gt;とういわけでまともに読めるのは活字の洋書だけということになりました。&lt;/p&gt;

&lt;h2 id=&#34;その他にも試してみた&#34;&gt;その他にも試してみた&lt;/h2&gt;

&lt;h3 id=&#34;青空文庫&#34;&gt;青空文庫&lt;/h3&gt;

&lt;p&gt;ブラウザ上で読む書籍といえばやはり青空文庫でしょう。&lt;/p&gt;

&lt;p&gt;こちらはいわゆる電子書籍のような UI はないものの、普通に読むことができました。やはり正しくマークアップされた HTML はこういうとき強いですね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.yuyat.jp/images/oculus-go-kindle/aozora.png&#34; width=&#34;670&#34; height=&#34;666&#34;&gt;&lt;/p&gt;

&lt;h3 id=&#34;amazon-prime-video&#34;&gt;Amazon Prime Video&lt;/h3&gt;

&lt;p&gt;書籍ではないですが、同じ Amazon ということで Amazon Prime Video も試してみましたが、これは普通に視聴できました。&lt;/p&gt;

&lt;p&gt;アプリではなくとも、再生さえできれば Netflix アプリと同じく最高の体験が得られます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Kindle は割と残念な感じでしたが、ブラウザベースの電子書籍サービスは試してみる価値が大いにあるでしょう。&lt;/p&gt;

&lt;p&gt;自分では試せてないですが、Windows 機を持っているのであれば、&lt;a href=&#34;https://bigscreenvr.com/&#34;&gt;Bigscreen&lt;/a&gt; 上で &lt;a href=&#34;https://www.amazon.co.jp/dp/B011UEHYWQ&#34;&gt;Kindle for Windows&lt;/a&gt; を開いてみるというのもいいかもしれません。&lt;/p&gt;

&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B078MQQJPZ&amp;linkId=3c1b7ebb75d985e65a7231323224f485&#34;&gt;&lt;/iframe&gt;
&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B0184N7WWS&amp;linkId=1bf535dc833fa92a3a33c2a213f3bdb2&#34;&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>bundle install には --clean を指定する (特に Circle CI では)</title>
      <link>https://blog.yuyat.jp/post/bundle-install-clean/</link>
      <pubDate>Mon, 16 Apr 2018 21:28:11 +0900</pubDate>
      
      <guid>https://blog.yuyat.jp/post/bundle-install-clean/</guid>
      <description>

&lt;h2 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;bundle install&lt;/code&gt; を &lt;code&gt;--clean&lt;/code&gt; オプション付きで実行することで、もう使っていない gem や古いバージョンの gem が削除されます。&lt;/p&gt;

&lt;p&gt;さもないと、Circle CI 上における Bundler のキャッシュの restore はどんどん遅くなります。&lt;/p&gt;

&lt;h2 id=&#34;前提&#34;&gt;前提&lt;/h2&gt;

&lt;p&gt;この記事では Circle CI 2.0 において、&lt;code&gt;store_cache&lt;/code&gt; と &lt;code&gt;restore_cache&lt;/code&gt; を使って、Bundler の gem をキャッシュしているプロジェクトを対象としています。&lt;/p&gt;

&lt;h2 id=&#34;キャッシュの-restore-が遅い&#34;&gt;キャッシュの restore が遅い！！&lt;/h2&gt;

&lt;p&gt;ある日ふと、Circle CI におけるキャッシュの restore にすごく時間がかかっていることに気づきました。&lt;/p&gt;

&lt;p&gt;その時のプロジェクトにおいては Bundler のキャッシュだけでなんと &lt;strong&gt;1.2 GB&lt;/strong&gt;、時間にして &lt;strong&gt;2 分&lt;/strong&gt; もかかっていました。
そのプロジェクトは Workflow が三段階になっていたので、全体で 2 x 3 = &lt;strong&gt;6 分&lt;/strong&gt; もキャッシュの restore にかかっていることになります。&lt;/p&gt;

&lt;p&gt;素の状態から &lt;code&gt;bundle install&lt;/code&gt; はもっともっと時間がかかるので、これでも意味なくはないけど、もっと速くしたいですね。&lt;/p&gt;

&lt;h2 id=&#34;起きていた問題&#34;&gt;起きていた問題&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;bundle install&lt;/code&gt; では、&lt;code&gt;Gemfile&lt;/code&gt; から削除された gem であったり、バージョンアップ前の古い gem を削除することなく、ディレクトリ中に保持します。&lt;/p&gt;

&lt;p&gt;そのため、プロジェクトを続けていると、主に gem をアップデートするごとに、もう使っていない gem がどんどん増えて行くことになります。&lt;/p&gt;

&lt;p&gt;Circle CI の場合、ディレクトリ内を丸ごとキャッシュするので、gem のアップデート時にも古いバージョンが残ったまま、また新たにキャッシュを store し直すことになるため、キャッシュが時間を追うごとに肥大化します。&lt;/p&gt;

&lt;h2 id=&#34;キャッシュをクリアしてみる&#34;&gt;キャッシュをクリアしてみる&lt;/h2&gt;

&lt;p&gt;とりあえずキャッシュキーを変更することで、丸ごとキャッシュをクリアしてみました。&lt;/p&gt;

&lt;p&gt;キャッシュの設定は以下のようになっていました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;    steps:
      - checkout
      - restore_cache:
          keys:
            - v1-api-bundle-{{ arch }}-{{ checksum &amp;quot;Gemfile.lock&amp;quot; }}
            - v1-api-bundle-
      - run: bundle check --path=vendor/bundle || bundle install --path=vendor/bundle --jobs=4 --retry=3
      - save_cache:
          key: v1-api-bundle-{{ arch }}-{{ checksum &amp;quot;Gemfile.lock&amp;quot; }}
          paths:
            - ~/api/vendor/bundle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;キーの prefix の &lt;code&gt;v1-&lt;/code&gt; を &lt;code&gt;v2-&lt;/code&gt; に変更することで、キャッシュがヒットしなくなるので、とりあえずキャッシュがクリアされました。&lt;/p&gt;

&lt;p&gt;一度キャッシュをゼロから再生成した後、&lt;code&gt;restore_cache&lt;/code&gt; を確認したところ、ファイルサイズが &lt;strong&gt;154MB&lt;/strong&gt;、restore にかかる時間は &lt;strong&gt;11 秒&lt;/strong&gt; と、大幅に改善されました。&lt;/p&gt;

&lt;h2 id=&#34;別の方法を検討してみる&#34;&gt;別の方法を検討してみる&lt;/h2&gt;

&lt;p&gt;とりあえずキャッシュをクリアすることで restore の時間を大幅に改善することはわかりましたが、いつのまにか遅くなっていって、気づいた頃に手動でクリアする、というのはダルいですね。&lt;/p&gt;

&lt;p&gt;というわけでいいオプションが Bundler にないものかと &lt;code&gt;bundle install --help&lt;/code&gt; したところ、良さそうななオプションが見つかりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--clean
       On finishing the installation Bundler is going to remove any gems not present in the current Gemfile(5). Don&#39;t worry, gems currently in use will not be removed.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こちらが意図している通りの挙動なのか、試してみましょう。&lt;/p&gt;

&lt;p&gt;まずは以下のような &lt;code&gt;Gemfile&lt;/code&gt; を用意します。あとでアップデートするために、あえて現時点でやや古いバージョンを指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;source &#39;https://rubygems.org&#39;

gem &#39;concurrent-ruby&#39;, &#39;1.0.0&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この状態で &lt;code&gt;bundle install --path=vendor/bundle&lt;/code&gt; し、ディレクトリ内をチェックします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bundle install --path=vendor/bundle
Fetching gem metadata from https://rubygems.org/..
Resolving dependencies...
Using bundler 1.16.1
Fetching concurrent-ruby 1.0.0
Installing concurrent-ruby 1.0.0
Bundle complete! 1 Gemfile dependency, 2 gems now installed.
Bundled gems are installed into `./vendor/bundle`

$ ls -l vendor/bundle/ruby/2.5.0/gems/
total 0
drwxr-xr-x  6 yuya  staff  204 Apr 16 21:24 concurrent-ruby-1.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここまではいいですが、ここで &lt;code&gt;Gemfile&lt;/code&gt; 中のバージョンを &lt;code&gt;&#39;1.0.5&#39;&lt;/code&gt; に変えてもう一度 &lt;code&gt;bundle install&lt;/code&gt; し、もう一度ディレクトリの中身を確認してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bundle install --path=vendor/bundle
Fetching gem metadata from https://rubygems.org/..
Resolving dependencies...
Using bundler 1.16.1
Using concurrent-ruby 1.0.5 (was 1.0.0)
Bundle complete! 1 Gemfile dependency, 2 gems now installed.
Bundled gems are installed into `./vendor/bundle`

$ ls -l vendor/bundle/ruby/2.5.0/gems/
total 0
drwxr-xr-x  6 yuya  staff  204 Apr 16 23:10 concurrent-ruby-1.0.0
drwxr-xr-x  6 yuya  staff  204 Apr 16 23:09 concurrent-ruby-1.0.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やはりバージョン違いの同一 gem が重複してしまいました。&lt;/p&gt;

&lt;p&gt;ここで &lt;code&gt;--clean&lt;/code&gt; オプション付きでやってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bundle install --path=vendor/bundle --clean
Using bundler 1.16.1
Using concurrent-ruby 1.0.5
Bundle complete! 1 Gemfile dependency, 2 gems now installed.
Bundled gems are installed into `./vendor/bundle`
Removing concurrent-ruby (1.0.0)

$ ls -l vendor/bundle/ruby/2.5.0/gems/
total 0
drwxr-xr-x  6 yuya  staff  204 Apr 16 23:13 concurrent-ruby-1.0.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;古いバージョンが消えました！&lt;/p&gt;

&lt;p&gt;なお、一度 &lt;code&gt;--clean&lt;/code&gt; で実行すると、設定が &lt;code&gt;.bundle/config&lt;/code&gt; に保存され、次回以降は &lt;code&gt;--clean&lt;/code&gt; なしでも同じ挙動になるようです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Ruby/Bundler ではこのようになっていましたが、他のパッケージマネージャーでも同様の問題には気をつけた方が良いでしょう。&lt;/p&gt;

&lt;p&gt;JavaScript における &lt;code&gt;yarn&lt;/code&gt; はデフォルトで同じような挙動になるので、気にする必要はないと思います。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--path&lt;/code&gt; を指定している場合は基本的に思考停止で &lt;code&gt;--clean&lt;/code&gt; を指定するのが良いでしょう。&lt;/p&gt;

&lt;p&gt;逆に &lt;code&gt;--path&lt;/code&gt; を指定せずに、グローバルに gem を共有している場合はおそらく &lt;code&gt;--clean&lt;/code&gt; を使わない方が良いと思います。意図せず別プロジェクトではまだ使っている gem を消しちゃうので。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>プログラマが 2017 年に買って良かったもの</title>
      <link>https://blog.yuyat.jp/post/best-buys-2017/</link>
      <pubDate>Mon, 01 Jan 2018 06:00:00 +0900</pubDate>
      
      <guid>https://blog.yuyat.jp/post/best-buys-2017/</guid>
      <description>

&lt;p&gt;あけましておめでとうございます。&lt;/p&gt;

&lt;p&gt;2016 年の記事は思いの外読まれたおかげで &lt;a href=&#34;http://amzn.to/2ElqIwx&#34;&gt;Anova&lt;/a&gt; が買えたので、今年も書いてみます。&lt;/p&gt;

&lt;p&gt;傾向として、去年は引越しに伴った生活関係の買い物が多かったですが、その辺の買い物は落ち着いて、今年は自宅の作業環境周りでの買い物が多かったように思います。&lt;/p&gt;

&lt;h2 id=&#34;作業環境編&#34;&gt;作業環境編&lt;/h2&gt;

&lt;h3 id=&#34;philips-4k対応-43型ワイド液晶ディスプレイ-bdm4350uc-11-http-amzn-to-2coo5f5&#34;&gt;&lt;a href=&#34;http://amzn.to/2Coo5f5&#34;&gt;Philips 4K対応 43型ワイド液晶ディスプレイ BDM4350UC/11&lt;/a&gt;&lt;/h3&gt;

&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B01D9FP20A&amp;linkId=4479882176573af57d5302439a714c93&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;今年の買い物としては一番の大物の部類です。&lt;/p&gt;

&lt;p&gt;元々 Apple の Thunderbolt Display (27 インチ) を使っていたんですが、モニターアームを取り付けようとしてる最中の&lt;a href=&#34;http://twilog.org/yuya_takeyama/date-170514&#34;&gt;悲しい事故&lt;/a&gt;でお亡くなりになってしまっていました。&lt;/p&gt;

&lt;p&gt;リビングのテレビ (39 インチ) よりも大きいものを机に置くのはどうか、という思いがあって長いこと放置してましたが、いろんな人の評価を見ているうちに買ってました。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;en&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;ある会社のエンジニアに、「4Kディスプレイは必要か？」と聞いて回ったら、「まあ、あれば嬉しいですけど。。」くらいの温度感だった。でも、実際に買い与えてみたら、ほぼ全員が「すごい！ぜんぜん違う！」というような感想になった。人間は、頭で想像するだけでは「一覧性」の重要さが理解できない&lt;/p&gt;&amp;mdash; fromdusktildawn (@fromdusktildawn) &lt;a href=&#34;https://twitter.com/fromdusktildawn/status/877699851751800832?ref_src=twsrc%5Etfw&#34;&gt;June 22, 2017&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;別候補としてはもう少し小さいサイズの曲面ディスプレイというのもありましたが、まだ全体的に高かったのと、仕事で React Native の開発もするようになって、単純に画面の広さが欲しくなったのでこちらにしました。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;en&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;快適に React Native 開発できる画面サイズ手に入った &lt;a href=&#34;https://t.co/NzJls6vf2l&#34;&gt;pic.twitter.com/NzJls6vf2l&lt;/a&gt;&lt;/p&gt;&amp;mdash; Yuya Takeyama ◢͟￨⁴⁶ (@yuya_takeyama) &lt;a href=&#34;https://twitter.com/yuya_takeyama/status/930103679478145024?ref_src=twsrc%5Etfw&#34;&gt;November 13, 2017&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;結果すごく満足しています。&lt;/p&gt;

&lt;h3 id=&#34;エルゴトロン-lx-デスクマウント-モニターアーム-ホワイト-45-490-216-http-amzn-to-2csegwe&#34;&gt;&lt;a href=&#34;http://amzn.to/2CsegwE&#34;&gt;エルゴトロン LX デスクマウント モニターアーム ホワイト 45-490-216&lt;/a&gt;&lt;/h3&gt;

&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B01FW15TV6&amp;linkId=36c528bca8655766b12234bf9bce4f26&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;デカいディスプレイの購入に伴って、机を広く使えるように書いました。&lt;/p&gt;

&lt;p&gt;机の上は割と散らかっていて Mac mini、Google Home、電源タップの他に、キーボード (楽器の方) とかも置いてますが、問題なく作業スペースを確保できています。&lt;/p&gt;

&lt;p&gt;このアームですが、すごく気に入ったのでもう一つ買ってしまいました。僕の机はリビングの隅っこ背を向ける形で置いてるんですが、テレビも机にアームで設置するようにしました。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;en&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;PC のモニターに続いてテレビも机にアームで設置するようにした。重量が机の片側に寄っててバランス悪いから足もう一本要りそう &lt;a href=&#34;https://t.co/bjZi0cNWkp&#34;&gt;pic.twitter.com/bjZi0cNWkp&lt;/a&gt;&lt;/p&gt;&amp;mdash; Yuya Takeyama ◢͟￨⁴⁶ (@yuya_takeyama) &lt;a href=&#34;https://twitter.com/yuya_takeyama/status/946978408059113473?ref_src=twsrc%5Etfw&#34;&gt;December 30, 2017&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;(40 インチ超って書いてるけどテレビは実は 39 インチだった)&lt;/p&gt;

&lt;p&gt;普段テレビは部屋側に向けてますが、机側に向けることで BGV を流しつつ作業することもできます。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;en&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;机側に向けることもできて便利。40 インチ超が 2 枚ならぶとなかなかの迫力 &lt;a href=&#34;https://t.co/HIkf7MCOVY&#34;&gt;pic.twitter.com/HIkf7MCOVY&lt;/a&gt;&lt;/p&gt;&amp;mdash; Yuya Takeyama ◢͟￨⁴⁶ (@yuya_takeyama) &lt;a href=&#34;https://twitter.com/yuya_takeyama/status/946982525167026176?ref_src=twsrc%5Etfw&#34;&gt;December 30, 2017&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;アーム側の VESA マウント規格としては 100x100 ですが、モニター側はいずれも 200x100 だったので以下のアダプタを使って取り付けてます。&lt;/p&gt;

&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B00LCKZ79Q&amp;linkId=e5e993e1790ac92b6e08332a767159ce&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;(200x200 って書いてあるけど 200x100 にもできます)&lt;/p&gt;

&lt;h3 id=&#34;magnet-window-manager-for-mac-http-magnet-crowdcafe-com&#34;&gt;&lt;a href=&#34;http://magnet.crowdcafe.com/&#34;&gt;Magnet: Window manager for Mac&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.yuyat.jp/images/best-buys-2017/magnet.png&#34; width=&#34;250&#34; height=&#34;547&#34;&gt;&lt;/p&gt;

&lt;p&gt;これはいわゆるタイル型のウィンドマネージャーで、画面が広くなったので欲しくなりました。&lt;/p&gt;

&lt;p&gt;同種のソフトとしては、調べた感じでは &lt;a href=&#34;https://ianyh.com/amethyst/&#34;&gt;Amethyst&lt;/a&gt; とかの方がメジャーっぽかったんですが、Magnet の方が覚えることが少ない感じだったのでこっちにしました。&lt;/p&gt;

&lt;p&gt;分割のカスタマイズ性でいうと Amethyst の方が高そうなので、困ってきたらまた考えると思いますが、今のところ Magnet で全然困ってないです。&lt;/p&gt;

&lt;h3 id=&#34;ipad-pro-10-5インチ-wi-fi-512gb-http-amzn-to-2emea9c-x-apple-pencil-http-amzn-to-2enarat&#34;&gt;&lt;a href=&#34;http://amzn.to/2EmEA9C&#34;&gt;iPad Pro 10.5インチ Wi-Fi 512GB&lt;/a&gt; x &lt;a href=&#34;http://amzn.to/2Enarat&#34;&gt;Apple Pencil&lt;/a&gt;&lt;/h3&gt;

&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B073PWCVXB&amp;linkId=53a66e7439ff1235345b803ae1b21331&#34;&gt;&lt;/iframe&gt;
&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B018MX3PNU&amp;linkId=95b04cb3ff0b631b8e78ae65051b094b&#34;&gt;&lt;/iframe&gt;
&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B073BL7THQ&amp;linkId=1ec557bad85e56f31b9af83937a375b6&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;iPad を 2011 年に買った iPad 2 を長いこと使っていたんですが、ここ数年はさすがにスペック的にキツかったので使わなくなっていました。&lt;/p&gt;

&lt;p&gt;書籍は Kindle Whitepaper で十分でしたが、漫画はカラー的にもサイズ的にもやはり iPad が良かったのもあって結構衝動的に書いました。&lt;/p&gt;

&lt;p&gt;ジムで走りながら Hulu とかを見るのにも使ってますが、仕事的には Apple Pencil を使ってポンチ絵を描くのに使いました。&lt;a href=&#34;http://quipper.hatenablog.com/entry/2017/12/06/060641&#34;&gt;会社ブログのこの記事&lt;/a&gt;の図とかも &lt;a href=&#34;https://itunes.apple.com/jp/app/notability/id360593530?mt=8&#34;&gt;Notability&lt;/a&gt; というアプリで書いてます。&lt;/p&gt;

&lt;h3 id=&#34;icoco-スマホスタンド-iphone-ipad-デスクホルダー-http-amzn-to-2c1yocb&#34;&gt;&lt;a href=&#34;http://amzn.to/2C1yOcb&#34;&gt;ICOCO スマホスタンド iPhone iPad デスクホルダー&lt;/a&gt;&lt;/h3&gt;

&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B01N5QYXGT&amp;linkId=cc72fe2afeb87b690a012bbece39e15d&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;ベッドで寝ながら iPad で Hulu を観たりする用に買いました。元々は机に取り付けたりもしていましたが、今はテレビをアームで取り付けたことによって、完全にベッド専用になりました。&lt;/p&gt;

&lt;p&gt;これは寒い日にベッドで使っていると一日がそれだけで終わってしまってなかなか危険です。&lt;/p&gt;

&lt;p&gt;角度をうねうね好きに変えられるのと、そこそこ強いので iPad Pro を取り付けても、動画を観てるだけならちゃんと安定します。Kindle ページめくりのためにタッチしたりするとさすがに揺れます。&lt;/p&gt;

&lt;h3 id=&#34;apple-airpods-http-amzn-to-2c28tru&#34;&gt;&lt;a href=&#34;http://amzn.to/2C28TRu&#34;&gt;Apple AirPods&lt;/a&gt;&lt;/h3&gt;

&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B01N2VMGT6&amp;linkId=05d8de33ee176bd94e6fb69bd828dfea&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;普段の移動中は 2009 年ぐらいに買った audio-technica のカナル型イヤホンを使っていましたが、ゴムの耳栓が片方なくなったままだったこともあって買い替えを検討していました。&lt;/p&gt;

&lt;p&gt;当初は &lt;a href=&#34;http://amzn.to/2lws6DZ&#34;&gt;earin&lt;/a&gt; とかも検討していましたが、充電時間だったり iPhone との連携がしっかりしていたことなどから AirPods にしました。&lt;/p&gt;

&lt;p&gt;職場では Bose の &lt;a href=&#34;http://amzn.to/2C2agzC&#34;&gt;QuietComfort 25&lt;/a&gt; を使っていて、ノイズキャンセリング機能だったり音質だったりといったスペック面ではどう考えてもそっちの方が上ですが、つけた時の身軽さから最近はもっぱら AirPods の方を使っています。&lt;/p&gt;

&lt;p&gt;ジムで走るときにつけていても全然落ちることがなく、快適です。ただ、耳の形の個人差ですぐ落ちる人もいるらしいので、買う前に試着して確かめるのがいいと思います。&lt;/p&gt;

&lt;h2 id=&#34;生活編&#34;&gt;生活編&lt;/h2&gt;

&lt;h3 id=&#34;ikea-の可変式食卓-http-www-ikea-com-jp-ja-catalog-products-40365795&#34;&gt;&lt;a href=&#34;http://www.ikea.com/jp/ja/catalog/products/40365795/&#34;&gt;IKEA の可変式食卓&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;元々は円形の食卓を使っていたんですが、デッドスペースが大きいので四角形の食卓を探していました。&lt;/p&gt;

&lt;p&gt;2 人暮らしなので基本的にはそんなに大きいものじゃなくていいんですが、たまに人が来たときに困ったりしていたので大きくできるのは良いです。引き出しがあるのも便利。&lt;/p&gt;

&lt;h3 id=&#34;amazon-echo-dot-http-amzn-to-2de7ck2&#34;&gt;&lt;a href=&#34;http://amzn.to/2DE7Ck2&#34;&gt;Amazon Echo Dot&lt;/a&gt;&lt;/h3&gt;

&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B072B5BTLK&amp;linkId=6213027d305dc8b96718b09ca66e61c1&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;まだ買ったばかりで全然活用はできてないんですが、Lambda にコードをデプロイするだけで自分のアプリ (Alexa Skill) が動かせるのはハッカー心を突き動かされるものがあって Google Home よりも楽しい気がしてます。プログラマにはおすすめ。&lt;/p&gt;

&lt;p&gt;詳しくはこちらの記事にて。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.yuyat.jp/post/alexa-skill-keyakizaka46/&#34;&gt;欅坂46 の情報が聞ける Alexa Skill を作った&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;google-home-https-store-google-com-product-google-home&#34;&gt;&lt;a href=&#34;https://store.google.com/product/google_home&#34;&gt;Google Home&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;正直まだまだだなと思うところはあるものの、普通に毎日使っています。用途としては以下のような感じです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Chromecast の操作

&lt;ul&gt;
&lt;li&gt;YouTube&lt;/li&gt;
&lt;li&gt;Netflix&lt;/li&gt;
&lt;li&gt;Google Play Music&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ifttt.com/&#34;&gt;IFTTT&lt;/a&gt; と &lt;a href=&#34;http://nature.global/&#34;&gt;Nature Remo&lt;/a&gt; を使った家電の操作

&lt;ul&gt;
&lt;li&gt;照明&lt;/li&gt;
&lt;li&gt;エアコン&lt;/li&gt;
&lt;li&gt;テレビ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://radiko.jp/&#34;&gt;Radiko&lt;/a&gt; の再生&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;照明は &lt;a href=&#34;http://amzn.to/2q6qxC7&#34;&gt;Philips Hue&lt;/a&gt; も買いましたが、明るさが足りないのとランニングコストの高さを考えると、あくまで飛び道具であってメインでの使用は厳しい気がしています。&lt;/p&gt;

&lt;p&gt;うちのマンションは元々伝統がリモコン式で、Nature Remo に信号を学習させることで普通の蛍光灯が Google Home で操作できるようになったので、実はそっちだけで十分ということがすぐにわかりました。&lt;/p&gt;

&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B072MYJYD1&amp;linkId=115d3ef3eac44aa3cd224bc63f9b454c&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;まだまだだなと思うのは単純に全然賢くないところです。かなりルールベース感があって、学習してくれてる感はあまり感じません。&lt;/p&gt;

&lt;h3 id=&#34;nature-remo-http-nature-global&#34;&gt;&lt;a href=&#34;http://nature.global/&#34;&gt;Nature Remo&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Indiegogo で back したのは去年だったと思いますが、今年の 5 月末にようやく受け取りました。&lt;/p&gt;

&lt;p&gt;元々は「エアコンの温度を勝手にいい感じにしてくれるヤツ」だと思ってましたが、そっちの機能は全然まだまだだと思います。&lt;/p&gt;

&lt;p&gt;それよりは単純に赤外線学習リモコンとしては簡単に使えるので、そっちで使っています。&lt;/p&gt;

&lt;p&gt;テレビはテレビ局ごとに信号を登録して、いずれも Google Home から操作できるようにしています。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;en&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;Google Home 買ってからの IFTTT の様子 &lt;a href=&#34;https://t.co/qBJJFTtLBw&#34;&gt;pic.twitter.com/qBJJFTtLBw&lt;/a&gt;&lt;/p&gt;&amp;mdash; Yuya Takeyama ◢͟￨⁴⁶ (@yuya_takeyama) &lt;a href=&#34;https://twitter.com/yuya_takeyama/status/931935866536148993?ref_src=twsrc%5Etfw&#34;&gt;November 18, 2017&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;一個一個登録していかないといけないのは面倒ですね。&lt;/p&gt;

&lt;p&gt;あと IFTTT からのトリガー 1 回につき 1 つの信号しか送れないので、テレビとエアコンと照明をまとめて消したりというのはできないし、テレビの音量も 1 つずつしか変えられないのは辛いので、その辺はなんとかして欲しいところです。&lt;/p&gt;

&lt;h2 id=&#34;音楽編&#34;&gt;音楽編&lt;/h2&gt;

&lt;h3 id=&#34;欅坂46-関連いろいろ-http-amzn-to-2endpa8&#34;&gt;&lt;a href=&#34;http://amzn.to/2EnDpa8&#34;&gt;欅坂46 関連いろいろ&lt;/a&gt;&lt;/h3&gt;

&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B072KRPMTB&amp;linkId=e8f89e2aaf38fc8c2109d6b8db69d497&#34;&gt;&lt;/iframe&gt;
&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B01BHPEC9G&amp;linkId=bb244653d24a6f6d787f814d263ed5ee&#34;&gt;&lt;/iframe&gt;
&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B06VV1DVBJ&amp;linkId=67ed252a3a49cc81b952cae6c13140ec&#34;&gt;&lt;/iframe&gt;
&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B075N3P398&amp;linkId=83a0c29df107eb627c626a78735a2bd0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.yuyat.jp/post/alexa-skill-keyakizaka46/&#34;&gt;Alexa の記事&lt;/a&gt;にも買いたので詳細は避けますが、年末に急にハマりました。&lt;/p&gt;

&lt;p&gt;曲でいうとエキセントリックと不協和音が特に好きですが、最近は避雷針を何度も聞いてます。あとはメロディがセーラー服と機関銃を思わせる平手友梨奈のソロ曲山手線もいいですね。&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/65v7JSBpQ4U&#34; frameborder=&#34;0&#34; gesture=&#34;media&#34; allow=&#34;encrypted-media&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/gfzuzDrVRVM&#34; frameborder=&#34;0&#34; gesture=&#34;media&#34; allow=&#34;encrypted-media&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/8y14n7mEVlo&#34; frameborder=&#34;0&#34; gesture=&#34;media&#34; allow=&#34;encrypted-media&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/WqAGACYJiNM&#34; frameborder=&#34;0&#34; gesture=&#34;media&#34; allow=&#34;encrypted-media&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B077312MD6&amp;linkId=46ee789e403a52d743d1a9d3938a8810&#34;&gt;&lt;/iframe&gt;
&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=4778316118&amp;linkId=1e571381d34f90c69c8e2f0b7fe373bd&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;雑誌も新刊を中心にバックナンバーも含めて買っていますが、今泉佑唯が表紙の BRODY に載っている、ミュージックビデオ監督のインタビューはすごく良かったです。MV 見直したくなります。&lt;/p&gt;

&lt;p&gt;あとは最近出たクイックジャパンも良かったです。最近の平手友梨奈は健康・精神面が心配されることも多いですが、インタビューを読むとこの先がかなり楽しみになりました。心配がなくなるわけではないけど。&lt;/p&gt;

&lt;h3 id=&#34;seafaring-strangers-private-yacht-http-amzn-to-2csr3za&#34;&gt;&lt;a href=&#34;http://amzn.to/2Csr3za&#34;&gt;Seafaring Strangers: Private Yacht&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.numerogroup.com/series/wayfaring-strangers&#34;&gt;Wayfaring Strangers&lt;/a&gt; シリーズ等でいろんなジャンルのレア音源の再発を行なっている &lt;a href=&#34;http://www.numerogroup.com/&#34;&gt;Numero Group&lt;/a&gt; からの AOR のコンピレーションです。夏を感じられるので、夏頃はずっと聴いていました。&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/Y_AZLXg3nNM&#34; frameborder=&#34;0&#34; gesture=&#34;media&#34; allow=&#34;encrypted-media&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2 id=&#34;その他&#34;&gt;その他&lt;/h2&gt;

&lt;h3 id=&#34;ニンテンドークラシックミニ-スーパーファミコン-http-amzn-to-2coful1&#34;&gt;&lt;a href=&#34;http://amzn.to/2CoFUL1&#34;&gt;ニンテンドークラシックミニ スーパーファミコン&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;正直自宅では 2、3 回ぐらいしかやってないんですが、同年代の家に集まるときはかなり盛り上がれるので買って良かったです。&lt;/p&gt;

&lt;h3 id=&#34;キャリーバッグ-http-amzn-to-2lys1j8&#34;&gt;&lt;a href=&#34;http://amzn.to/2lys1j8&#34;&gt;キャリーバッグ&lt;/a&gt;&lt;/h3&gt;

&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B01N95WMBW&amp;linkId=afa85d51591cedbb28f2e7b6f9f58a9e&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;去年は Quipper に入って初の海外出張でインドネシアに行ったりしたんですが、キャリーバッグを持ってなくて、妹に借りたバッグで行って来ました。キャリーバッグを今まで使ったことがなかったんですが、便利だったのでより良いのを買ってみました。&lt;/p&gt;

&lt;p&gt;その後、実家への行き来が何度かあって飛行機に乗ることが多かったので重宝しました。特に、ローラーがしっかりしているので、重くてもほとんど勝手に動いてくれるのが良いです。&lt;/p&gt;

&lt;h3 id=&#34;a-w-ルートビア-http-amzn-to-2lyv1hv&#34;&gt;&lt;a href=&#34;http://amzn.to/2lyV1Hv&#34;&gt;A&amp;amp;W ルートビア&lt;/a&gt;&lt;/h3&gt;

&lt;iframe style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=yuyat-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B002EMXOKU&amp;linkId=7625460f685dd980e23c05f634a14c45&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;会社の近くにある &lt;a href=&#34;http://www.shakeshack.jp/&#34;&gt;SHAKE SHACK&lt;/a&gt; というバーガー屋で初めて飲んでハマりました。飲むサロンパスとも言われる、ケミカルな味が魅力の炭酸飲料です。&lt;/p&gt;

&lt;p&gt;Amazon でまとめ買いするか、ドン・キホーテで少しずつ買って飲んでます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;あまり意識したつもりはなかったけど、終わってみれば&lt;a href=&#34;http://localhost:1313/post/best-buys-2016/&#34;&gt;年明けにやりたいと思っていた&lt;/a&gt;「家電のスマート化」「自宅のプログラミング環境への投資」の両方ともできていたので良かったですね。&lt;/p&gt;

&lt;p&gt;2018 年はスマートホーム化をもっと高度化させつつ、良くなったプログラミング環境で色々作っていければなと思ってます。あとはゲーミングチェアが欲しい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>欅坂46 の情報が聞ける Alexa Skill を作った</title>
      <link>https://blog.yuyat.jp/post/alexa-skill-keyakizaka46/</link>
      <pubDate>Sun, 31 Dec 2017 20:30:19 +0900</pubDate>
      
      <guid>https://blog.yuyat.jp/post/alexa-skill-keyakizaka46/</guid>
      <description>

&lt;p&gt;なかなか来てくれなかった &lt;a href=&#34;http://amzn.to/2zT3Hxt&#34;&gt;Amazon Echo Dot&lt;/a&gt; の招待がようやく来たので、早速買ってみました。&lt;/p&gt;

&lt;p&gt;ある日、テレビでたまたま、平井堅のノンフィクションという曲に合わせて踊る平手友梨奈さんを観て衝撃を受けて以来、欅坂46 の事ばっかり考えているし CD や雑誌をすごい勢いで買って &lt;a href=&#34;http://countdownjapan.jp/&#34;&gt;COUNTDOWN JAPAN&lt;/a&gt; ではライブも観て来ました。&lt;a href=&#34;https://www.youtube.com/watch?v=8y14n7mEVlo&#34;&gt;避雷針&lt;/a&gt;すごく良かったです。&lt;/p&gt;

&lt;p&gt;というわけで題材は欅坂46 です。&lt;/p&gt;

&lt;h2 id=&#34;作ったもの&#34;&gt;作ったもの&lt;/h2&gt;

&lt;p&gt;今のところ 2 つの機能があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;特定の日にちのスケジュールを読み上げる&lt;/li&gt;
&lt;li&gt;特定の日にちまたは月が誕生日のメンバーを読み上げる。&lt;/li&gt;
&lt;/ul&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/fAYt8XUeUFY&#34; frameborder=&#34;0&#34; gesture=&#34;media&#34; allow=&#34;encrypted-media&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;なお、データについては&lt;a href=&#34;http://www.keyakizaka46.com/&#34;&gt;欅坂46公式サイト&lt;/a&gt;から勝手にスクレイピングしているので、公式のストア (?) には登録していないですしそのつもりもありません。ベータテスト機能で自分をテスターとして登録しています。&lt;/p&gt;

&lt;p&gt;自分でデプロイできる人はそれでやってみてもいいですし、ちょっと使ってみたい、という方は &lt;a href=&#34;https://twitter.com/yuya_takeyama&#34;&gt;Twitter&lt;/a&gt; に声かけてもらえればベータテスターとして招待することもできます。&lt;/p&gt;

&lt;h2 id=&#34;ソースコード&#34;&gt;ソースコード&lt;/h2&gt;

&lt;p&gt;GitHub に MIT License で公開しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yuya-takeyama/alexa-keyakizaka-info&#34;&gt;yuya-takeyama/alexa-keyakizaka-info&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また、Alexa Skill の Intent とかの設定は以下のようになっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/yuya-takeyama/c05d131d63865aa952eaa37470dc400f&#34;&gt;欅坂情報 Alexa Skill の Intent とかの設定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;構成&#34;&gt;構成&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;言語: TypeScript&lt;/li&gt;
&lt;li&gt;動作環境: AWS Lambda (Node.js 6.10)&lt;/li&gt;
&lt;li&gt;主なライブラリ

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/alexa-sdk&#34;&gt;alexa-sdk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/axios&#34;&gt;axios&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tmpvar/jsdom&#34;&gt;jsdom&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;仕組み&#34;&gt;仕組み&lt;/h2&gt;

&lt;p&gt;先にも書いた通り、スケジュール・誕生日のいずれも公式サイトのスケジュールページからスクレイピングしてます。&lt;/p&gt;

&lt;p&gt;誕生日については、事前にデータだけ用意をしておけばスクレイピングは必要ないですし、メンバー名から誕生日を読み上げる事も実装できるので、そういう感じに作り変えるかもしれません。&lt;/p&gt;

&lt;p&gt;必要な情報を元に読み上げる文言を組み立てて、alexa-sdk を使ってレスポンスを返してます。&lt;/p&gt;

&lt;p&gt;リクエストを受けて動作するプログラムは AWS Lambda 上で動作しており、Alexa Skill としては基本的な構成だと思います。&lt;/p&gt;

&lt;h2 id=&#34;作ってみて思ったこと&#34;&gt;作ってみて思ったこと&lt;/h2&gt;

&lt;h3 id=&#34;タイムゾーンは基本的に考えなくて良い&#34;&gt;タイムゾーンは基本的に考えなくて良い&lt;/h3&gt;

&lt;p&gt;これはもちろん Skill の性質にもよるんですが、今回のケースでいうとタイムゾーンのことを考慮する必要はありませんでした。&lt;/p&gt;

&lt;p&gt;今回でいうと「今日」とか「あさって」とか「来週の金曜日」といった感じに日付を指定しますが、これらはリクエストの中に Slot として含まれます。まぁ平たくいうとパラメータです。これは事前に定義したものを受け取れます。&lt;/p&gt;

&lt;p&gt;これらの日付については Amazon Echo 側のタイムゾーンに基づいて送られてくるようで、例えば日本時間 12 月 31 日の午前 4 時は UTC ではまだ 12 月 30 の 19 時ですが、Lambda には「2017-12-31」という文字列で受け取れます。&lt;/p&gt;

&lt;p&gt;開発中にハマったのが、Service Simulator から「今日」と送ると前日の日付が送られて来て、おそらく UTC の日付が送られて来ていたんですが、Amazon Echo Dot 実機からだと JST と思われる日付で受け取れていました。&lt;/p&gt;

&lt;p&gt;今回は日付ベースの処理しかなかったのでこういう結論になりましたが、例えば時刻の計算を行うようなアプリとかだと当然タイムゾーンは考慮する必要があると思います。&lt;/p&gt;

&lt;h3 id=&#34;開発中はフィードバックのループを回すのが大変&#34;&gt;開発中はフィードバックのループを回すのが大変&lt;/h3&gt;

&lt;p&gt;作る前から想像していましたが、やはり試行錯誤を繰り返すのに時間がかかります。&lt;/p&gt;

&lt;p&gt;今回は CircleCI で AWS Lambda へのデプロイを自動化したところで効率よく回せるようになって来ました。&lt;/p&gt;

&lt;p&gt;本番用とテスト用二つの Alexa Skill を登録しておいて、機能ブランチへの push ごとにテスト用のアプリを更新、master にマージすると本番を更新、としています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yuya-takeyama/alexa-keyakizaka-info/blob/master/.circleci/config.yml&#34;&gt;.circleci/config.yml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今のところ awscli のインストールに時間がかかってしまっていて、あらかじめインストールした Docker Image を作っておけば短縮できると思いますが、まぁその辺は後回しで。&lt;/p&gt;

&lt;p&gt;あとはスケジュールの取得とか誕生日の取得とかの部分は独立してテストできるようにしておくと細かくテストできて良かったです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yuya-takeyama/alexa-keyakizaka-info/tree/master/bin&#34;&gt;./bin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;手軽にハックできて楽しい&#34;&gt;手軽にハックできて楽しい！&lt;/h3&gt;

&lt;p&gt;先に Google Home も買っていて、そっちは Nature Remo と IFTTT を組み合わせて照明、テレビ、エアコンの操作に毎日使っていますが、まだアプリの開発には手を出していません。&lt;/p&gt;

&lt;p&gt;一方 Alexa は Lambda に Node.js のコードをちょっとデプロイするだけで簡単に動かせてお手軽なので、購入初日から手をつけていました。&lt;/p&gt;

&lt;p&gt;事前に AWS のアカウントを持っているかとか、Lambda を触ったことがあるかによっても変わってくるとは思いますが、その辺を仕事で触っている人には本当に簡単だと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>peco で S3 のバケット・ファイル一覧を見るやつを作ったらめちゃくちゃ便利なのができた</title>
      <link>https://blog.yuyat.jp/post/peco-s3.zsh/</link>
      <pubDate>Fri, 12 May 2017 00:46:00 +0900</pubDate>
      
      <guid>https://blog.yuyat.jp/post/peco-s3.zsh/</guid>
      <description>

&lt;p&gt;釣りっぽいタイトルにしてしまったけどまぁ主観なので&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yuya-takeyama/peco-s3.zsh&#34;&gt;yuya-takeyama/peco-s3.zsh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これがどんなものなのかはこのスクリーンキャストを見てもらうのが一番良いでしょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.yuyat.jp/images/peco-s3.zsh/screenshot.gif&#34; alt=&#34;Screenshot&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;機能&#34;&gt;機能&lt;/h2&gt;

&lt;h3 id=&#34;バケットの一覧化&#34;&gt;バケットの一覧化&lt;/h3&gt;

&lt;p&gt;このスクリーンキャストではバケット名を指定してその中身を一覧化していますが、引数を省略した場合はバケットの一覧が表示され、選択することでさらにその中のファイルを一覧化することができます。&lt;/p&gt;

&lt;h3 id=&#34;元の一覧に戻る&#34;&gt;元の一覧に戻る&lt;/h3&gt;

&lt;p&gt;バケット・ディレクトリの中に移動したあとで Esc を押すと元のディレクトリに戻ることができます。&lt;/p&gt;

&lt;h3 id=&#34;peco-によるフィルタ&#34;&gt;peco によるフィルタ&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/peco/peco&#34;&gt;peco&lt;/a&gt; をベースとしているので、文字列で対象をフィルタしながらファイル・ディレクトリを選択することができます。&lt;/p&gt;

&lt;h3 id=&#34;s3cat-コマンドの生成&#34;&gt;s3cat コマンドの生成&lt;/h3&gt;

&lt;p&gt;ファイルを選択すると、そのファイルを出力するための &lt;code&gt;s3cat&lt;/code&gt; コマンドがプロンプトに出力されます。&lt;/p&gt;

&lt;p&gt;そのまま実行すればファイルを出力できますし、パイプでつないで別のコマンドに繋げていくこともできます。&lt;/p&gt;

&lt;h3 id=&#34;ファイルの再帰的な一覧化&#34;&gt;ファイルの再帰的な一覧化&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;--recursive&lt;/code&gt; (&lt;code&gt;-r&lt;/code&gt;) オプションを使うことで、ディレクトリ以下のファイルも再帰的に取得し、全て一覧化することができます。&lt;/p&gt;

&lt;h2 id=&#34;使い方-インストール手順&#34;&gt;使い方・インストール手順&lt;/h2&gt;

&lt;p&gt;GitHub の &lt;code&gt;README.md&lt;/code&gt; を参照してください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yuya-takeyama/peco-s3.zsh&#34;&gt;yuya-takeyama/peco-s3.zsh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;終わりに&#34;&gt;終わりに&lt;/h2&gt;

&lt;p&gt;zsh というかシェルスクリプトはあんまり得意じゃないので、コード的には結構拙い感じだと思います。&lt;br /&gt;
良ければ Pull Request ください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MongoMapper で Mass Assignment を自動検出する</title>
      <link>https://blog.yuyat.jp/post/automatic-mass-assignment-detection-for-mongomapper/</link>
      <pubDate>Thu, 13 Apr 2017 01:14:30 +0900</pubDate>
      
      <guid>https://blog.yuyat.jp/post/automatic-mass-assignment-detection-for-mongomapper/</guid>
      <description>

&lt;p&gt;GitHub が &lt;a href=&#34;https://www.infoq.com/jp/news/2012/03/GitHub-Compromised&#34;&gt;Mass Assignment 脆弱性を突かれて&lt;/a&gt;からもう 5 年も経っているんですね。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ActiveRecord&lt;/code&gt; (というか &lt;code&gt;ActiveModel&lt;/code&gt;) では適切に &lt;code&gt;.permit&lt;/code&gt; したパラメータ以外は &lt;code&gt;ActiveModel::ForbiddenAttributesError&lt;/code&gt; が発生するようになっていますが、&lt;code&gt;MongoMapper&lt;/code&gt; ではそうなってなかったので対応させてみました。&lt;/p&gt;

&lt;h2 id=&#34;プラグインの実装&#34;&gt;プラグインの実装&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ActiveModel&lt;/code&gt; の &lt;a href=&#34;https://apidock.com/rails/ActiveModel/ForbiddenAttributesProtection&#34;&gt;&lt;code&gt;ForbiddenAttributesProtection&lt;/code&gt;&lt;/a&gt; をそのまま利用します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;module MongoMapper
  module Plugins
    module ForbiddenAttributesProtection
      extend ActiveSupport::Concern

      included do
        include ::ActiveModel::ForbiddenAttributesProtection
      end

      def attributes=(attrs = {})
        super sanitize_for_mass_assignment(attrs)
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;利用する&#34;&gt;利用する&lt;/h2&gt;

&lt;p&gt;とりあえず &lt;code&gt;MongoMapper::Document&lt;/code&gt; を &lt;code&gt;include&lt;/code&gt; した全てのクラスに適用するには以下を呼ぶ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;MongoMapper::Document.plugin(MongoMapper::Plugins::ForbiddenAttributesProtection)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし、各クラスが &lt;code&gt;MongoMapper::Document&lt;/code&gt; を &lt;code&gt;include&lt;/code&gt; するのより先に実行されている必要があると思います。&lt;/p&gt;

&lt;p&gt;もしくは個別のクラスに適用する場合は普通に &lt;code&gt;include&lt;/code&gt; でも良いです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;class User
  include MongoMapper::Document
  include MongoMapper::Plugins::ForbiddenAttributesProtection
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、適切に &lt;code&gt;.permit&lt;/code&gt; していない &lt;code&gt;ActionController::Parameters&lt;/code&gt; をセットしたりしようとすると &lt;code&gt;ActiveModel::ForbiddenAttributesError&lt;/code&gt; が発生するようになります。&lt;/p&gt;

&lt;p&gt;もちろん雑に &lt;code&gt;.to_h&lt;/code&gt; したりしたものを渡したりするとそれは検出できないので、そういうのは人間が気づく必要があります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Heroku で Resque を Graceful Shutdown する</title>
      <link>https://blog.yuyat.jp/post/graceful-shutdown-resque-in-heroku/</link>
      <pubDate>Mon, 10 Apr 2017 02:02:59 +0900</pubDate>
      
      <guid>https://blog.yuyat.jp/post/graceful-shutdown-resque-in-heroku/</guid>
      <description>

&lt;p&gt;Heroku で Resque を動かす場合、何も考えないでセットアップすると、デプロイによるプロセスの再起動時や、Dyno のスケールダウン時に Worker プロセスが強制終了され、&lt;code&gt;Resque::DirtyExit&lt;/code&gt; としてエラーになってしまいます。&lt;/p&gt;

&lt;p&gt;これを避けるために正しく &lt;strong&gt;Graceful Shutdown&lt;/strong&gt; する方法について調べてみました。&lt;/p&gt;

&lt;h2 id=&#34;前提とするバージョン&#34;&gt;前提とするバージョン&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Ruby 2.4.1&lt;/li&gt;
&lt;li&gt;Rails 5.0.2&lt;/li&gt;
&lt;li&gt;Resque 1.27.2&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;graceful-shutdown-とは-この記事における定義&#34;&gt;Graceful Shutdown とは (この記事における定義)&lt;/h2&gt;

&lt;p&gt;厳密な定義を知っているわけではないですが、この記事では以下のような定義で話を進めます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Graceful Shutdown: 中途半端なデータが残らないよう、行儀よくプロセスを終了する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さらにこれを細分化して、この記事では以下のように呼ぶことにします。これらは私の造語で、全く一般的でない呼び方です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Halfway Graceful Shutdown: やりかけの処理に完了処理を行ってから全体の途中で処理を終了する&lt;/li&gt;
&lt;li&gt;Entire Graceful Shutdown: すべての処理が完了してから終了する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例えば、100 件のデータを処理する Worker があり、50 件目を行っている途中で終了のシグナルを受け取った場合、その 50 件目まで正しくやりきったタイミングで終了するのが &lt;strong&gt;Halfway Graceful Shutdown&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;そして、50 件目の段階で終了のシグナルを受け取っても、100 件すべてをやりきった上で終了するのが &lt;strong&gt;Entire Graceful Shutdown&lt;/strong&gt; となります。&lt;/p&gt;

&lt;p&gt;これに対して、いきなり終了してしまうことをここでは &lt;strong&gt;Immediate Shutdown&lt;/strong&gt; と呼ぶことにします。
これも一般的な用語なのかはわからないですが、検索した感じではこういう用語を使っているドキュメントもいくつか見つかりました。&lt;/p&gt;

&lt;h2 id=&#34;resque-における-graceful-shutdown&#34;&gt;Resque における Graceful Shutdown&lt;/h2&gt;

&lt;p&gt;Resque では Graceful Shutdown を行う方法として、QUIT シグナルによる方法が提供されています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/resque/resque#signals&#34;&gt;resque/resque: Signals&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;つまり Resque のプロセス ID に対して以下のようなコマンドを実行すれば良いことになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kill -QUIT PID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、&lt;code&gt;QUIT&lt;/code&gt; を受け取った時の挙動は、この記事の定義で言えば Entire Graceful Shutdown です。&lt;/p&gt;

&lt;h2 id=&#34;heroku-で-graceful-shutdown-を行う際の問題点&#34;&gt;Heroku で Graceful Shutdown を行う際の問題点&lt;/h2&gt;

&lt;p&gt;Heroku のような PaaS では任意の UNIX プロセスに対して任意のシグナルを送ることはできないことが一般的でしょう。 (少なくとも Heorku ではできません)&lt;/p&gt;

&lt;p&gt;それでいて、以下のような場合は &lt;code&gt;TERM&lt;/code&gt; シグナルが送信されます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;デプロイの実行による Dyno の再起動&lt;/li&gt;
&lt;li&gt;Dyno のスケールダウン&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Heroku ではこれらの場合、まずは &lt;code&gt;TERM&lt;/code&gt; シグナルが送られ、それでもプロセスが残っている場合は 30 秒後に &lt;code&gt;KILL&lt;/code&gt; シグナルが送られて強制終了となります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://devcenter.heroku.com/articles/error-codes#r12-exit-timeout&#34;&gt;Heroku Error Codes: R12 - Exit Timeout&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そして &lt;code&gt;TERM&lt;/code&gt; が送られた場合の Resque のデフォルトの挙動は Immediate Shutdown です。&lt;/p&gt;

&lt;h2 id=&#34;heroku-で-resque-を-graceful-shutdown-する&#34;&gt;Heroku で Resque を Graceful Shutdown する&lt;/h2&gt;

&lt;p&gt;実は &lt;a href=&#34;https://github.com/resque/resque#resque&#34;&gt;Resque の README&lt;/a&gt; や &lt;a href=&#34;https://devcenter.heroku.com/articles/queuing-ruby-resque#process-options&#34;&gt;Heroku のドキュメント&lt;/a&gt;にもいろいろ説明はあるんですが、以下のような理由で、一読しただけ正しく理解するのは難しいと思いました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Resque の &lt;code&gt;master&lt;/code&gt; ブランチの README に書いてある内容の一部は現状の最新版 (&lt;code&gt;v1.27.2&lt;/code&gt;) では使えないのでややこしい

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/resque/resque/pull/1514&#34;&gt;&lt;code&gt;RESQUE_PRE_SHUTDOWN_TIMEOUT&lt;/code&gt;&lt;/a&gt; というオプションはまだリリースされていない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Resque のドキュメントには記載されていないが有用なオプションがある

&lt;ul&gt;
&lt;li&gt;Entire Gracful Shutdown を行う上で必要な &lt;a href=&#34;https://github.com/resque/resque/pull/1007&#34;&gt;GRACEFUL_TERM&lt;/a&gt; というオプション&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Heroku のドキュメントは Resque に関する情報が一部古いか間違っている

&lt;ul&gt;
&lt;li&gt;少なくとも Rails 5.0.2 では &lt;code&gt;rake resque:work&lt;/code&gt; ではなく &lt;code&gt;rake environment resque:work&lt;/code&gt; としないとエラーで Worker が起動できない&lt;/li&gt;
&lt;li&gt;SIGTERM から 10 秒後に SIGKILL、と言う説明があるが正しくは 30 秒&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Resque の &lt;code&gt;GRACEFUL_TERM&lt;/code&gt; についてはプルリクエストを送ればいいとして、Heroku のドキュメントの問題についてはどこに報告すべきかよくわからないので知ってる人は教えてください。&lt;/p&gt;

&lt;h3 id=&#34;halfway-graceful-shutdown&#34;&gt;Halfway Graceful Shutdown&lt;/h3&gt;

&lt;p&gt;これは実は以下の記事でほぼ説明されています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://webtech-walker.com/archive/2012/09/resque_heroku.html&#34;&gt;HerokuでResqueを使うときに優雅に再起動する&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ただしこれも 4 年半ほど前の記事なので、現時点では以下のようにする必要があるでしょう。&lt;/p&gt;

&lt;h4 id=&#34;worker-の実装&#34;&gt;Worker の実装&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;perform&lt;/code&gt; メソッドの中で &lt;code&gt;Resque::TermException&lt;/code&gt; を &lt;code&gt;rescue&lt;/code&gt; し、完了処理を実装します。&lt;/p&gt;

&lt;p&gt;これについては上記の記事通りで問題ありません。&lt;/p&gt;

&lt;h4 id=&#34;procfile&#34;&gt;Procfile&lt;/h4&gt;

&lt;p&gt;以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;resque: QUEUE=* TERM_CHILD=1 RESQUE_TERM_TIMEOUT=30 bundle exec rake environment resque:work
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現在のバージョンでは &lt;code&gt;QUEUE&lt;/code&gt; の指定が必須です。 (もちろん必要に応じて変更する)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TERM_CHILD&lt;/code&gt; をセットすると &lt;code&gt;TERM&lt;/code&gt; シグナルを受け取った時の挙動が変わります。&lt;/p&gt;

&lt;p&gt;デフォルトでは &lt;code&gt;TERM&lt;/code&gt; を受け取ると容赦なく Worker である子プロセスに &lt;code&gt;KILL&lt;/code&gt; を送り Immediate Shutdown となります。&lt;/p&gt;

&lt;p&gt;これに対して &lt;code&gt;TERM_CHILD&lt;/code&gt; をセットした場合は以下のような流れになります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Worker である子プロセスに対して &lt;code&gt;TERM&lt;/code&gt; を送る

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Resque::TermException&lt;/code&gt; が &lt;code&gt;raise&lt;/code&gt; される&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TERM_TIMEOUT&lt;/code&gt; に指定した秒数の間、子プロセスが終了するのを待つ&lt;/li&gt;
&lt;li&gt;それでも子プロセスが残っていれば今度は &lt;code&gt;KILL&lt;/code&gt; を送って強制終了する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;前述の Heroku の制限のため、&lt;code&gt;RESQUE_TERM_TIMEOUT&lt;/code&gt; は 30 秒以下にする必要があります。 (それ以上を指定しても結局 Heroku から &lt;code&gt;KILL&lt;/code&gt; される)&lt;/p&gt;

&lt;h3 id=&#34;resque-pre-shutdown-timeout-について&#34;&gt;&lt;code&gt;RESQUE_PRE_SHUTDOWN_TIMEOUT&lt;/code&gt; について&lt;/h3&gt;

&lt;p&gt;前述の通り未リリースではあるものの、&lt;code&gt;master&lt;/code&gt; ブランチに入っていてそのうち使えるようになると思われるこのオプションについても調べてみました。&lt;/p&gt;

&lt;p&gt;これは &lt;code&gt;TERM_CHILD&lt;/code&gt; をセットしている場合のみに有効なオプションで、子プロセスに &lt;code&gt;TERM&lt;/code&gt; を送る前の待ち時間を秒数で指定することができます。&lt;/p&gt;

&lt;p&gt;つまりこれは &lt;code&gt;Halfway Graceful Shutdown&lt;/code&gt; と &lt;code&gt;Entire Graceful Shutdown&lt;/code&gt; 複合です。&lt;/p&gt;

&lt;p&gt;例えば &lt;code&gt;Procfile&lt;/code&gt; を以下のようにした場合、&lt;code&gt;TERM&lt;/code&gt; を受け取った後の挙動は以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;resque: QUEUE=* TERM_CHILD=1 RESQUE_PRE_SHUTDOWN_TIMEOUT=20 RESQUE_TERM_TIMEOUT=10 bundle exec rake environment resque:work
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;子プロセスの処理が完了するまで 20 秒間待つ

&lt;ul&gt;
&lt;li&gt;この 20 秒間に処理が全て完了すれば Entire Graceful Shutdown&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;子プロセスに &lt;code&gt;TERM&lt;/code&gt; を送る

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Resque::TermException&lt;/code&gt; が &lt;code&gt;raise&lt;/code&gt; される&lt;/li&gt;
&lt;li&gt;この場合は Halfway Graceful Shutdown&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;子プロセスが終了するまでさらに 10 秒間待つ&lt;/li&gt;
&lt;li&gt;それでも子プロセスが残っていれば今度は &lt;code&gt;KILL&lt;/code&gt; を送って強制終了する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体的な秒数については実際に動いている Worker の実行時間を元にチューニングするのが良いでしょう。&lt;/p&gt;

&lt;p&gt;いずれにせよ &lt;code&gt;RESQUE_PRE_SHUTDOWN_TIMEOUT&lt;/code&gt; と &lt;code&gt;RESQUE_TERM_TIMEOUT&lt;/code&gt; の合計は 30 以下にする必要があります。&lt;/p&gt;

&lt;h3 id=&#34;entire-graceful-shutdown&#34;&gt;Entire Graceful Shutdown&lt;/h3&gt;

&lt;p&gt;これについては説明されている記事が見つけられなかったので、自分で実際に Heroku で動かしながらわかったことを元に書きます。&lt;/p&gt;

&lt;h4 id=&#34;worker-の実装-1&#34;&gt;Worker の実装&lt;/h4&gt;

&lt;p&gt;Halfway Graceful Shutdown を行わないのであれば、&lt;code&gt;Resque::TermException&lt;/code&gt; の &lt;code&gt;rescue&lt;/code&gt; は不要です。&lt;/p&gt;

&lt;h4 id=&#34;procfile-1&#34;&gt;Procfile&lt;/h4&gt;

&lt;p&gt;以下のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;resque: QUEUE=* GRACEFUL_TERM=1 bundle exec rake environment resque:work
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合は &lt;code&gt;TERM_CHILD&lt;/code&gt; を指定してはいけません。指定した場合、&lt;code&gt;GRACEFUL_TERM&lt;/code&gt; の設定が&lt;a href=&#34;https://github.com/resque/resque/blob/v1.27.2/lib/resque/worker.rb#L866&#34;&gt;無効果されます&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&#34;graceful-term-とは&#34;&gt;&lt;code&gt;GRACEFUL_TERM&lt;/code&gt; とは&lt;/h4&gt;

&lt;p&gt;これは &lt;code&gt;TERM&lt;/code&gt; を受け取った時の処理を (Entire) Graceful Shutdown にするというものです。&lt;/p&gt;

&lt;p&gt;前述の通り今の所ドキュメント化されていないようです。&lt;/p&gt;

&lt;h2 id=&#34;どちらの方法を選ぶべきか&#34;&gt;どちらの方法を選ぶべきか&lt;/h2&gt;

&lt;p&gt;基本的には Halfway Graceful Shutdown を選ぶべきでしょう。&lt;/p&gt;

&lt;p&gt;Heroku では 30 秒制限がある以上、Entire Graceful Shutdown を選ぶとしても、Worker は全て 30 秒で完了できなくてはなりません。通常 1 分かかる処理があったとして、20 秒時点で &lt;code&gt;TERM&lt;/code&gt; を受け取った場合、Entire Graceful Shutdown では最後の 10 秒分の処理を残して強制終了されてしまうからです。&lt;/p&gt;

&lt;p&gt;30 秒間に全てを終えることはできなくても、今やりかけの分だけ綺麗に完了させることはできるかもしれません。&lt;/p&gt;

&lt;p&gt;ただし、Halfway Graceful Shutdown を行うには、前述の通り &lt;code&gt;Resque::TermException&lt;/code&gt; を正しく &lt;code&gt;rescue&lt;/code&gt; するような実装を行わなければなりません。&lt;/p&gt;

&lt;p&gt;全ての Worker が 30 秒もかからないような場合であれば、その実装をサボって Entire Graceful Shutdown で妥協するのも良いでしょう。&lt;/p&gt;

&lt;h2 id=&#34;関連するソースの読み方&#34;&gt;関連するソースの読み方&lt;/h2&gt;

&lt;p&gt;ここに書いてあることは基本的には &lt;code&gt;Resque::Worker&lt;/code&gt; だけ読めば全て書いてあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/resque/resque/blob/master/lib/resque/worker.rb&#34;&gt;resque/lib/resque/worker.rb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Resque は想像していたよりは意外と重厚な感じではなく、比較的読みやすい分量だと思いました。UNIX プロセスについての勉強としても面白いと思うのでオススメです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Node.js のスタックトレースを控えめにする supress-stack-trace 書いた</title>
      <link>https://blog.yuyat.jp/post/supress-stack-trace/</link>
      <pubDate>Wed, 29 Mar 2017 02:21:11 +0900</pubDate>
      
      <guid>https://blog.yuyat.jp/post/supress-stack-trace/</guid>
      <description>

&lt;p&gt;最近仕事で React/Redux で構築されたアプリを触っていて、&lt;a href=&#34;https://mochajs.org/&#34;&gt;mocha&lt;/a&gt; でテストがコケたときのスタックトレースがうるさい感じだったので &lt;code&gt;node_modules&lt;/code&gt; 内のエラーを除外するためのものを作ってみた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yuya-takeyama/supress-stack-trace&#34;&gt;yuya-takeyama/supress-stack-trace&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;まだ npm には登録してないのでとりあえず GitHub から直接インストールする必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yarn add -D yuya-takeyama/supress-stack-trace
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使い方は読み込むだけで OK&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require(&#39;supress-stack-trace&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mocha の場合は &lt;code&gt;mocha.opts&lt;/code&gt; に &lt;code&gt;--require supress-stack-trace&lt;/code&gt; とかしてあげるだけでいいと思います。&lt;/p&gt;

&lt;p&gt;今の仕事では &lt;a href=&#34;https://www.npmjs.com/package/mocha-webpack&#34;&gt;mocha-webpack&lt;/a&gt; を使っていて、&lt;code&gt;mocha-webpack.opts&lt;/code&gt; に同じ感じに指定すればうまくできました。&lt;/p&gt;

&lt;p&gt;なお、&lt;a href=&#34;https://github.com/evanw/node-source-map-support&#34;&gt;source-map-support&lt;/a&gt; のように &lt;code&gt;Error.prepareStackTrace&lt;/code&gt; をオーバーライドするライブラリを既に使っている場合は、そのあとで読み込むのが良いと思います。ライブラリの組み合わせによっては動かないこともあると思います。&lt;/p&gt;

&lt;h2 id=&#34;使用感&#34;&gt;使用感&lt;/h2&gt;

&lt;p&gt;このようにすっきりします。&lt;/p&gt;

&lt;h3 id=&#34;before&#34;&gt;Before&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;     Error: error
      at app/components/foo/Foo.jsx:18:11
      at Object.LinkedValueUtils.executeOnChange (node_modules/react-dom/lib/LinkedValueUtils.js:129:1)
      at ReactDOMComponent._handleChange (node_modules/react-dom/lib/ReactDOMInput.js:232:1)
      at Object.invokeGuardedCallback [as invokeGuardedCallbackWithCatch] (node_modules/react-dom/lib/ReactErrorUtils.js:26:1)
      at executeDispatch (node_modules/react-dom/lib/EventPluginUtils.js:83:1)
      at Object.executeDispatchesInOrder (node_modules/react-dom/lib/EventPluginUtils.js:108:1)
      at executeDispatchesAndRelease (node_modules/react-dom/lib/EventPluginHub.js:43:1)
      at executeDispatchesAndReleaseSimulated (node_modules/react-dom/lib/EventPluginHub.js:51:1)
      at forEachAccumulated (node_modules/react-dom/lib/forEachAccumulated.js:26:1)
      at Object.EventPluginHub.processEventQueue (node_modules/react-dom/lib/EventPluginHub.js:255:1)
      at node_modules/react-dom/lib/ReactTestUtils.js:340:1
      at ReactDefaultBatchingStrategyTransaction.TransactionImpl.perform (node_modules/react-dom/lib/Transaction.js:140:1)
      at Object.ReactDefaultBatchingStrategy.batchedUpdates (node_modules/react-dom/lib/ReactDefaultBatchingStrategy.js:62:1)
      at Object.batchedUpdates (node_modules/react-dom/lib/ReactUpdates.js:97:1)
      at node_modules/react-dom/lib/ReactTestUtils.js:338:1
      at ReactWrapper.&amp;lt;anonymous&amp;gt; (node_modules/enzyme/build/ReactWrapper.js:776:1)
      at ReactWrapper.single (node_modules/enzyme/build/ReactWrapper.js:1421:1)
      at ReactWrapper.simulate (node_modules/enzyme/build/ReactWrapper.js:769:1)
      at Context.&amp;lt;anonymous&amp;gt; (test/components/foo/Foo-test.js:168:20)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;after&#34;&gt;After&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;     Error: error
      at app/components/foo/Foo.jsx:18:11
      at Context.&amp;lt;anonymous&amp;gt; (test/components/foo/Foo-test.js:168:20)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;仕組み&#34;&gt;仕組み&lt;/h2&gt;

&lt;p&gt;V8 には &lt;a href=&#34;https://github.com/v8/v8/wiki/Stack-Trace-API&#34;&gt;Stack Trace API&lt;/a&gt; というものがあって、&lt;code&gt;Error.prepareStackTrace&lt;/code&gt; という関数をセットすることでスタックトレースの出力をいじることができます。&lt;/p&gt;

&lt;p&gt;ただこれは API 的にはあまりイケてなくて、エラーとスタックトレースを受け取って文字列を返す関数なので、チェインすることはちょっと難しい感じです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;source-map-support&lt;/code&gt; も &lt;code&gt;Error.prepareStackTrace&lt;/code&gt; をセットしているので、既にセットされた関数があった場合は、その出力の文字列から &lt;code&gt;node_modules/&lt;/code&gt; と含まれた行だけ消す、みたいなことをしています。&lt;/p&gt;

&lt;p&gt;なので例えばエラーメッセージに &lt;code&gt;node_modules/&lt;/code&gt; と含まれていた場合はそこまで省略されてしまいます。 (気が向いたらなおす)&lt;/p&gt;

&lt;h2 id=&#34;その他&#34;&gt;その他&lt;/h2&gt;

&lt;p&gt;あとはやっぱり環境変数で supress しないモードとかもあったらいいと思うんですが、いい名前が思いつかないのでとりあえず後回し。&lt;/p&gt;

&lt;p&gt;思いついたら npm に公開しようと思います。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>